---
extends: _layouts.post
section: content
title: Почему мы не можем их получить
date: 2022-04-08
description: Перевод серии статей о дженериках в PHP. Часть 3.
tags: [php, generics]
original:
  url: https://stitcher.io/blog/generics-in-php-3
  title: "Generics in PHP: The basics"
---
# Почему мы не можем их получить

Мы собираемся глубоко погрузиться в то, что происходит за кулисами, когда речь заходит о дженериках и PHP. Это очень
интересно и очень важно для понимания того, почему дженерики еще не поддерживаются как первоклассные граждане в PHP.

Давайте начнем.

Дженерики не придут в PHP. Это был вывод Никиты в прошлом году. Это было просто невозможно.

Чтобы понять, почему Никита так сказал, нам нужно посмотреть, как можно реализовать дженерики. В общем, есть три
возможных способа сделать это, языки программирования, которые поддерживают дженерики, в основном используют один из
этих трех методов.

Первый из них называется мономорфизированными дженериками. Давайте вернемся к первому посту этой серии, где я показал
пример коллекции:

```php
<?php

class StringCollection extends Collection
{
    public function offsetGet(mixed $key): string 
    { /* … */ }
}

class UserCollection extends Collection
{
    public function offsetGet(mixed $key): User 
    { /* … */ }
}
```

Я объяснил, что мы можем вручную создать реализацию класса коллекции для каждого типа, для которого нам нужна коллекция.
Это было бы много ручной работы, было бы много кода, но это бы работало.

Мономорфизированные дженерики делают именно это, но автоматизированным способом, за кулисами. Во время выполнения PHP не
будет знать о родовом классе `Collection`, а скорее о двух или более конкретных реализациях:

```php
$users = new Collection<User>();
// Collection_User

$slugs = new Collection<string>();
// Collection_strin
```

## Мономорфизированные дженерики

Мономорфизированные дженерики — это совершенно правильный подход. Rust, например, использует их. Одним из преимуществ
является значительный прирост производительности, потому что больше нет проверок общих типов во время выполнения, все
разделяется на части перед выполнением кода.

Но это сразу же приводит нас к проблеме с мономорфными дженериками в PHP. В PHP нет явного шага компиляции, как в Rust,
чтобы разделить один общий класс на несколько конкретных реализаций, и, кроме того, мономорфные дженерики требуют
довольно много памяти, потому что вы создаете несколько копий одного класса с небольшими отличиями. Это может быть не
такой большой проблемой для скомпилированного двоичного кода Rust, но это серьезная проблема для PHP кода, запускаемого
из центральной точки, сервера, возможно, обслуживающего сотни или тысячи запросов в секунду.

## Reified Generics

Следующий вариант - это Reified Generics. Это реализация, в которой класс generic сохраняется как есть, а информация о
типе оценивается на лету, во время выполнения. В C# и Kotlin есть reified generics, и это наиболее близко к текущей
системе типов PHP, потому что PHP делает все свои проверки типов во время выполнения. Проблема здесь в том, что для
работы reified generics потребуется огромное количество рефакторинга кода ядра, и вы можете представить себе, как
увеличивается производительность, поскольку мы делаем все больше и больше проверок типов во время выполнения.

Это подводит нас к последнему варианту: полностью игнорировать дженерики во время выполнения. Ведите себя так, как будто
их нет, в конце концов, дженериковая реализация, например, класса коллекции будет работать с любым типом входных данных
в любом случае.

Таким образом, если мы игнорируем все проверки общих типов во время выполнения, то никаких проблем не возникает.

Ну, не так быстро. Игнорирование общих типов во время выполнения - кстати, это называется стиранием типов, так делают
Java и Python - создает некоторые проблемы для PHP.

Например: PHP не только использует типы для валидации, он также использует информацию о типах для преобразования
значений на лету из одного типа в другой - это и есть жонглирование типами, о котором я упоминал в первом посте этой
серии:

```php
<?php

function add(int $a, int $b): int 
{
    return $a + $b;
}

add('1', '2') // 3;
```

Если бы PHP проигнорировал общий тип этой коллекции "string", и мы случайно добавили бы в нее целое число, он не смог бы
предупредить нас об этом, если бы общий тип был стерт:

```php
<?php

$slugs = new Collection<string>();

$slugs[] = 1; // 1 не будет приведен к '1'
```

Вторая, более важная проблема со стиранием типов - возможно, вы уже кричите об этом на экране - заключается в том, что
типы исчезают. Зачем нам добавлять общие типы, если они стираются во время выполнения?

Это имеет смысл в Java и Pyton, потому что все определения типов проверяются перед выполнением кода с помощью
статического анализатора. Java, например, запускает встроенный статический анализатор при компиляции кода, чего PHP
просто не делает:
здесь нет шага компиляции, и уж точно нет встроенного статического анализатора типов.

С другой стороны... все преимущества проверки типов, о которых мы говорили в предыдущих постах, они не исходят от
встроенной в PHP проверки типов во время выполнения. К тому моменту, когда программа проверки типов PHP говорит нам, что
что-то не так, мы уже выполняем код. Ошибка типа, по сути, разрушает нашу программу.

Вместо этого, большая часть дополнительной ценности проверок типов исходит от статических анализаторов, которые не
требуют от нас выполнения нашего кода. Они довольно хорошо справляются с тем, чтобы убедиться в отсутствии ошибок типа
во время выполнения, если только вы, программист, предоставите достаточно информации о типе. Это не означает, что в
вашем коде не может быть ошибок, но вполне возможно написать PHP-код, который полностью статически проверяется и не
выдает никаких ошибок типа во время выполнения. Более того, статическая информация, которую мы получаем во время
написания кода, является самой ценной частью любой системы типов и не имеет ничего общего с проверкой типов во время
выполнения.

Так нужны ли нам проверки типов во время выполнения? Потому что это основная причина, по которой дженерики не могут быть
добавлены в PHP сегодня:
это либо слишком сложно, либо слишком ресурсоемко для PHP, чтобы проверять дженериковые типы во время выполнения.

Об этом в следующий раз, в последней статье этой серии.