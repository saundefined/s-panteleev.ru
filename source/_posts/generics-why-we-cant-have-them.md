---
extends: _layouts.post
section: content
title: Почему в PHP нет дженериков
date: 2022-04-08
description: Перевод серии статей о дженериках в PHP. Часть 3.
tags: [php, generics]
original:
  url: https://stitcher.io/blog/generics-in-php-3
  title: "Generics in PHP: Why we can't have them"
---

# Почему в PHP нет дженериков

Мы собираемся глубоко погрузиться в то, что происходит под капотом, когда речь заходит о дженериках и PHP. Очень
интересно и очень важно понять, почему дженерики до сих пор не поддерживаются как полноценные компоненты PHP.

Давайте начнём.

Дженерики не появятся в PHP. Таков
был [вывод Никиты](https://www.reddit.com/r/PHP/comments/j65968/ama_with_the_phpstorm_team_from_jetbrains_on/g7zg9mt/) в
прошлом году. Это просто было невыполнимо.

Чтобы понять, почему Никита так сказал, нужно посмотреть, как могут быть реализованы дженерики. В общем, есть три
возможных способа сделать это; языки программирования, которые поддерживают дженерики, в основном используют один из
этих трёх методов.

Первый из них называется Monomorphized Generics. Давайте вернёмся к первой статье этой серии, где я показывал этот
пример коллекции:

```php
<?php

class StringCollection extends Collection
{
    public function offsetGet(mixed $key): string 
    { /* … */ }
}

class UserCollection extends Collection
{
    public function offsetGet(mixed $key): User 
    { /* … */ }
}
```

Я объяснил, что мы можем вручную создавать реализации класса коллекции для каждого типа, для которого нам нужна
коллекция. Будет много ручной работы, будет много кода, но это будет работать.

Monomorphized Generics делают именно это, но автоматически, под капотом. Во время выполнения PHP не будет знать об общем
классе `Collection`, только о двух более конкретных реализациях:

```php
$users = new Collection<User>();
// Collection_User

$slugs = new Collection<string>();
// Collection_string
```

Monomorphized Generics — абсолютно правильный подход. Например, такой подход используется в Rust. Одним из преимуществ
является значительный прирост производительности, потому что больше нет проверок общих типов во время выполнения, всё
разделяется на части перед выполнением кода.

Но в PHP нет явного шага компиляции, как в Rust, чтобы разделить один общий класс на несколько конкретных реализаций, и,
кроме того, Monomorphized Generics потребляют довольно много памяти, потому что вы делаете несколько копий одного и того
же класса с некоторыми отличиями. Это может быть не такой большой проблемой для скомпилированного двоичного кода Rust,
но это серьёзная проблема для PHP-кода, запускаемого на сервере, возможно, обслуживающего сотни или тысячи запросов в
секунду.

Следующий вариант — Reified Generics. Реализация, в которой общий класс сохраняется как есть, а информация о типе
оценивается на лету во время выполнения. Reified Generics используются в C# и Kotlin и это наиболее близко к текущей
системе типов PHP, потому что PHP выполняет все проверки типов во время выполнения.

Проблема в том, что для работы Reified Generics потребовался бы огромный объем рефакторинга кода ядра PHP, а также
снизилась бы производительность, поскольку во время выполнения мы делали бы всё больше и больше проверок типов.

Это подводит нас к последнему варианту: полное игнорирование дженериков во время выполнения. Как будто их нет. В конце
концов, универсальная реализация, например, класса коллекции в любом случае будет работать с любым типом ввода.

Таким образом, если мы будем игнорировать проверки общих типов во время выполнения, проблем не возникает.

Ну, не так быстро. Игнорирование общих типов во время выполнения — это, кстати, называется стиранием типов в Java и
Python, создаёт некоторые проблемы в PHP.

Во-первых, PHP не только использует типы для проверки, он также использует информацию о типах для преобразования
значений на лету из одного типа в другой — это жонглирование типами, о котором я упоминал
в [первой статье](/post/generics-in-php/) этой серии:

```php
<?php

function add(int $a, int $b): int 
{
    return $a + $b;
}

add('1', '2') // 3;
```

Если бы PHP проигнорировал общий тип этой «строковой» коллекции, и мы случайно добавили бы к ней целое число, он не смог
бы нас об этом предупредить, если бы общий тип был стёрт:

```php
<?php

$slugs = new Collection<string>();

$slugs[] = 1; // 1 не будет приведено к '1'
```

Вторая и более важная проблема со стиранием типов, возможно, вы уже кричите об этом на свой экран, заключается в том,
что типы исчезли. Зачем нам добавлять общие типы, если они стираются во время выполнения?

Это имеет смысл в Java и Python, потому что все определения типов проверяются перед запуском кода с помощью статического
анализатора. Java, например, запускает встроенный статический анализатор при компиляции кода, то, чего PHP просто не
делает:
нет шага компиляции и уж точно нет встроенного статического анализатора типов.

С другой стороны... все преимущества проверки типов, о которых мы говорили в предыдущих постах, не берутся из
встроенного в PHP средства проверки типов во время выполнения. К тому времени, когда средство проверки типов PHP
сообщает нам, что что-то не так, мы уже выполняем код. Ошибка типа приводит к сбою нашей программы.

Вместо этого, большая часть дополнительной ценности проверок типов исходит от статических анализаторов, которые не
требуют запуска нашего кода. Они довольно хорошо проверяют, не может ли быть ошибок типов во время выполнения, если вы,
программист, предоставите достаточно информации о типах. Это не означает, что в вашем коде не может быть ошибок, но
вполне возможно написать PHP-код, который полностью статически проверен и не выдаёт никаких ошибок типа во время
выполнения.

Более того, статическая информация, которую мы получаем при написании кода, является самой ценной частью любой системы
типов и не имеет ничего общего с проверкой типов во время выполнения.

Так нужны ли нам проверки типов во время выполнения? Потому что это основная причина, по которой дженерики не могут быть
добавлены в PHP сегодня — это либо слишком сложно, либо слишком ресурсоёмко для PHP, чтобы проверять дженерики во время
выполнения.

Об этом в следующий раз, в последней статье этой серии.