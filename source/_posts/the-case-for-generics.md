---
extends: _layouts.post
section: content
title: Доводы в пользу дженериков
date: 2022-04-08
description: Перевод серии статей о дженериках в PHP. Часть 4.
tags: [php, generics]
original:
  url: https://stitcher.io/blog/generics-in-php-4
  title: "Generics in PHP: The basics"
---

# Доводы в пользу дженериков

Я начал эту серию с того, что хочу не только научить вас, но и привести свои аргументы в пользу того, что я считаю
наиболее жизнеспособным и логичным путем к добавлению дженериков в PHP.

После этого видео вы сами решите, согласны вы с этим или нет. Итак, ваша честь, я хотел бы начать свое заключительное
слово.

Добавление мономорфизированных или реифицированных дженериков не произойдет. По крайней мере, по мнению Никиты, который
провел обширное исследование на эту тему. Оба варианта либо создают проблемы с производительностью, либо просто требуют
слишком большого объема рефакторинга кода PHP для проверки типов во время выполнения, чтобы быть достижимыми в разумные
сроки.

Однако, если мы подумаем об истинной ценности дженериков, то она заключается не в проверке типов во время выполнения. К
тому времени, когда PHP сработает и, возможно, выдаст ошибку типа, мы уже выполним наш код. Наша программа аварийно
завершается. И я никогда не слышал, чтобы пользователи моих программ говорили: "О, это ошибка типа, все в порядке". Нет.
Программа упала, и это конец истории.

Проверка типов во время выполнения в PHP - очень полезный инструмент отладки, я согласен, и в некоторых случаях он
необходим для жонглирования типами. Но большая часть ценности системы типов PHP исходит от статического анализа.

Поэтому, если мы хотим дженерики в PHP, нам нужно изменить мышление:

Во-первых, разработчики должны принять статический анализ. Ирония заключается в том, что разработчики, которые хотят
дженерики и понимают их ценность, также понимают ценность статической проверки типов. Поэтому, хотя есть группа
разработчиков PHP, которым безразличен статический анализ, им также не стоит беспокоиться о ценности, которую приносят
дженерики. Потому что эти две вещи: дженерики и статическая проверка типов, просто не могут быть разделены.

Во-вторых, если интерналы PHP решат, что статически проверяемые дженерики имеют свое место в PHP, им следует задуматься,
следует ли оставить статический анализ в ведении сообщества или же они должны сыграть в этом свою роль. Либо создав
спецификацию, которой должен следовать каждый статический анализатор, либо выпустив свой собственный статический
анализатор типов. Второй вариант был бы предпочтительнее, но вы можете себе представить, какой это будет труд. Я не
думаю, что полагаться на проверенные инструменты третьих сторон должно быть проблемой.

В-третьих, жонглирование типами стало бы просто невозможным, по крайней мере, при использовании дженериков. Вам придется
довериться статической проверке типов. Это способ программирования, к которому разработчики PHP не очень привыкли, но
многие другие языки делают именно так, и это прекрасно работает. Статическая проверка типов невероятно мощная и точная.
Я могу представить, что разработчикам PHP трудно понять силу статически типизированных языков, если они не использовали
их раньше. Стоит изучить такие языки, как Rust, Java или даже TypeScript, чтобы оценить мощь систем статических типов.
Или вы можете начать использовать один из сторонних статических анализаторов PHP: Psalm или PHPStan.

Подводя итог: если мы хотим, чтобы в PHP были дженерики, со всеми преимуществами, которые они дают статическому анализу,
нам нужно принять тот факт, что дженерики, стираемые во время выполнения, являются единственным жизнеспособным путем.

В заключение я хотел бы сделать еще несколько замечаний.

Во-первых, есть аргумент, что то, что я описываю, уже возможно с помощью докблоков. Если вы вернетесь ко второй статье
этой серии, вы найдете там подробное объяснение различий, но позвольте мне быстро подвести итог:

- Докблоки не передают разработчикам ту же важность, что и встроенный синтаксис, именно поэтому в PHP 8 появились
  атрибуты; встроенный синтаксис имеет большее значение, чем докблоки.

- Кроме того, нет официальной спецификации того, как должны выглядеть общие аннотации при использовании блоков doc.
  Сегодня это большая проблема, поскольку все три основных статических анализатора имеют немного разные реализации.

Во-вторых, даже при стирании типов, мы все равно могли бы раскрывать информацию об общих типах через Reflection API. Я
не говорю, что информация о типах должна полностью исчезать во время выполнения, моя главная проблема в том, что PHP не
должен проверять общие типы во время выполнения. Я не уверен, какое влияние окажет на ядро PHP доступность информации о
родовых типах через отражение, поэтому я просто хочу сказать, что я не против этой идеи.

И, наконец, есть, конечно, другое решение. Теоретически его может использовать каждый. Оно хорошо зарекомендовало себя в
прошлом: TypeScript. Может существовать супермножество PHP, которое компилируется в обычный PHP, а во время компиляции
выполняет множество проверок типов и других интересных вещей. TypeScript пользуется огромной популярностью, и я думаю,
что если есть место для подобного подхода в серверных языках, то PHP, вероятно, является хорошим кандидатом. Однако
TypeScript не появился волшебным образом в одночасье. Он был создан опытными разработчиками языка, и это гораздо более
значительная задача, чем добавление в PHP дженериков, игнорируемых временем выполнения. Но кто знает, может быть,
когда-нибудь.

Учитывая все вышесказанное, я надеюсь, что вы нашли эту серию полезной и познавательной, я рассказал все, что хотел, о
дженериках. Я буду признателен, если вы поделитесь этой серией со своими коллегами и последователями - я считаю, что это
важная тема, и хочу, чтобы ситуация изменилась.