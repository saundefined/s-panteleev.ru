<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:yandex="https://news.yandex.ru"
     xmlns:media="https://search.yahoo.com/mrss/"
     xmlns:turbo="https://turbo.yandex.ru"
     version="2.0">
    <channel>
        <title>Сергей Пантелеев</title>
        <link>https://s-panteleev.ru</link>
        <description>Заметки на полях</description>
        <language>ru</language>
                    <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/the-case-for-generics</link>
    <pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Доводы в пользу дженериков</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/the-case-for-generics/cover.jpg">
            </figure>
        </header>
        <h1>Доводы в пользу дженериков</h1>

<p>Я начал эту серию с того, что хочу не только вас научить, но и привести свои аргументы, почему я считаю
наиболее важным и логичным путём добавление дженериков в PHP.</p>

<p>Решать вам, согласны вы с этим или нет. Итак, Ваша честь, я хотел бы начать своё последнее слово.</p>

<p><a href="/post/generics-why-we-cant-have-them/">Мономорфизированные или Материализованные дженерики</a> не будут добавлены.</p>

<p>По крайней мере, по словам Никиты, который провёл обширное исследование по этой теме. Оба варианта либо создают проблемы
с производительностью, либо просто требуют слишком большого объёма рефакторинга средства проверки типов PHP во время
выполнения, чтобы это можно было реализовать в разумные сроки.</p>

<p>Однако, если мы подумаем об истинной ценности дженериков, она заключается не в проверке типов во время выполнения. К
тому времени, когда сработает средство проверки типов во время выполнения PHP и, возможно, выдаст ошибку типа, мы уже
выполняем код. Это приведёт к сбою нашей программы. И я никогда не слышал, чтобы пользователи моих программ
говорили: «О, это ошибка типа, всё в порядке». Нет. Программа дала сбой, и точка.</p>

<p>Проверка типов во время выполнения в PHP — это очень полезный инструмент отладки, я согласен, и в некоторых случаях он
необходим при жонглировании типами. Но большая часть ценности системы типов PHP исходит от статического анализа.</p>

<p>Поэтому, если мы хотим использовать дженерики в PHP, нам нужно поменять мышление:</p>

<p>Во-первых, разработчики <strong>должны использовать статический анализ</strong>. Ирония здесь в том, что разработчики, которым нужны
дженерики, которые понимают их ценность, также понимают ценность статической проверки типов. PHP-разработчикам, которым
наплевать на статический анализ, также не стоит беспокоиться о ценности дженериков. Потому что эти две вещи, дженерики и
статическая проверка типов просто не могут быть разделены.</p>

<p>Во-вторых, если внутренние разработчики PHP решат, что статически проверяемые дженерики должны быть добавлены в PHP,
следует задаться вопросом: оставить ли статический анализ в ведении сообщества, либо <strong>создать спецификацию</strong>, которой
должен следовать каждый статический анализатор, либо реализовать свою <strong>собственную статическую проверку типов</strong>.</p>

<p>Второй вариант был бы предпочтительнее, но вы можете себе представить, какой это большой труд. Я не думаю, что полагаться
на проверенные сторонние инструменты будет проблемой.</p>

<p>В-третьих, <strong>жонглирование типами было бы просто невозможно</strong>, по крайней мере, при использовании дженериков. Вам придётся
доверять вашей статической проверке типов. Это способ программирования, к которому PHP-разработчики на самом деле не
привыкли, но многие другие языки делают именно так и это прекрасно работает. Статическая проверка типов невероятно
мощная и точная. Я могу себе представить, что разработчикам PHP трудно понять мощь языков со статической типизацией, не
использовав их раньше. Стоит изучить такие языки, как Rust, Java или даже TypeScript, чтобы оценить мощь систем
статических типов. Или вы можете начать использовать один из сторонних статических анализаторов PHP: Psalm или PHPStan.</p>

<p>Подводя итог: если мы хотим, чтобы в PHP были дженерики, со всеми преимуществами для статического
анализа, нам нужно принять тот факт, что дженерики, стираемые во время выполнения, являются единственным жизнеспособным
путём.</p>

<p>В заключение ещё несколько замечаний, на которые я хотел бы обратить внимание.</p>

<p>Во-первых, есть аргумент, что всё, описываемое мной, уже возможно с помощью Docblock-аннотаций. Если вы вернётесь
ко <a href="/post/generics-in-depth/">второй статье</a> этой серии, вы увидите, что я подробно объясняю различия, но позвольте мне
кратко подытожить:</p>

<ul>
<li><p>Docblock-аннотации не передают разработчикам ту же важность, как встроенный синтаксис, поэтому в PHP 8 появились
атрибуты; встроенный синтаксис имеет большее значение, чем Docblock.</p></li>
<li><p>Кроме того, нет официальной спецификации того, как должны выглядеть общие аннотации при использовании Docblock.
Сегодня это большая проблема, поскольку у всех трёх основных статических анализаторов немного разные реализации.</p></li>
</ul>

<p>Во-вторых, даже при стирании типов, мы всё ещё можем предоставлять информацию об общем типе с помощью Reflection API. Я
не говорю, что информация о типах должна полностью исчезать во время выполнения, моя главная проблема в том, что PHP не
должен проверять общие типы во время выполнения. Я не уверен, какое влияние окажет на ядро PHP доступность информации об
общих типах с помощью Reflection API, поэтому я просто хочу сказать, что не против этой идеи.</p>

<p>И, наконец, есть, конечно, другое решение. Теоретически его может использовать каждый. Оно хорошо зарекомендовало себя в
прошлом: TypeScript. TypeScript пользуется огромной популярностью, и я думаю, что если есть место для подобного подхода
в серверных языках, то PHP, вероятно, является отличным кандидатом. Однако TypeScript не появился волшебным образом в
одночасье. Он был создан опытными разработчиками языка и это гораздо более глобальная задача, чем добавление дженериков,
игнорируемых временем выполнения, в PHP. Но кто знает, может быть, когда-нибудь.</p>

<p>Учитывая всё вышесказанное, я надеюсь, что вы нашли эту серию статей полезной и познавательной, я сказал о дженериках
всё, что хотел. Я буду признателен, если вы поделитесь этой серией со своими коллегами и подписчиками — я считаю, что
это важная тема, и хочу, чтобы ситуация изменилась.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/generics-why-we-cant-have-them</link>
    <pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Почему в PHP нет дженериков?</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/generics-why-we-cant-have-them/cover.jpg">
            </figure>
        </header>
        <h1>Почему в PHP нет дженериков?</h1>

<p>Мы собираемся глубже погрузиться в то, что происходит под капотом, когда речь заходит о дженериках и PHP. Очень
интересно и очень важно понять, почему дженерики до сих пор не поддерживаются как полноценные компоненты PHP.</p>

<p>Давайте начнём.</p>

<p>Дженерики не появятся в PHP. Таков
был <a href="https://www.reddit.com/r/PHP/comments/j65968/ama_with_the_phpstorm_team_from_jetbrains_on/g7zg9mt/">вывод Никиты</a> в
прошлом году. Это просто невозможно было реализовать.</p>

<p>Чтобы понять, почему Никита так сказал, нужно разобраться, как могут быть реализованы дженерики. Есть три
возможных способа сделать это — языки программирования, которые поддерживают дженерики, в основном используют один из
этих трёх методов.</p>

<p>Первый из них — <strong>Мономорфизированные дженерики</strong> (Monomorphized Generics).
Давайте вернёмся к коллекции из <a href="/post/generics-in-php/">первой статьи</a> этой серии:</p>

<pre><code class="language-php">&lt;?php

class StringCollection extends Collection
{
    public function offsetGet(mixed $key): string 
    { /* … */ }
}

class UserCollection extends Collection
{
    public function offsetGet(mixed $key): User 
    { /* … */ }
}
</code></pre>

<p>Я объяснил, что мы можем вручную создавать реализации класса коллекции для каждого типа, для которого нам нужна коллекция.
Будет много ручной работы, будет много кода, но это будет работать.</p>

<p>Мономорфизированные дженерики именно это и делают, но автоматически, под капотом.
Во время выполнения PHP не будет знать об общем классе <code>Collection</code>, только о двух более конкретных реализациях:</p>

<pre><code class="language-php">$users = new Collection&lt;User&gt;();
// Collection_User

$slugs = new Collection&lt;string&gt;();
// Collection_string
</code></pre>

<p>Мономорфизированные дженерики — абсолютно правильный подход. Например, такой подход используется в Rust. Одним из преимуществ
является значительный прирост производительности, потому что больше нет проверок общих типов во время выполнения, всё
разделяется на части перед выполнением кода.</p>

<p>Но в PHP нет явного шага компиляции, как в Rust, чтобы разделить один общий класс на несколько конкретных реализаций, и,
кроме того, мономорфизированные дженерики потребляют довольно много памяти, потому что необходимо создать несколько копий одного и того
же класса с некоторыми отличиями. Это не такая большая проблема для скомпилированного двоичного кода Rust,
но это серьёзная проблема для PHP-кода, запускаемого на сервере, возможно, обслуживающего сотни или тысячи запросов в секунду.</p>

<p>Следующий метод — <strong>Материализованные дженерики</strong> (Reified Generics). Реализация, в которой общий класс сохраняется как есть, а информация о типе
оценивается на лету во время выполнения. Материализованные дженерики используются в C# и Kotlin и это наиболее близко к текущей
системе типов PHP, потому что PHP выполняет все проверки типов во время выполнения.</p>

<p>Проблема в том, что для работы материализованных дженериков потребовался бы огромный объем рефакторинга кода ядра PHP,
а также снизилась бы производительность, поскольку во время выполнения мы делали бы всё больше и больше проверок типов.</p>

<p>Это подводит нас к последнему методу: полное игнорирование дженериков во время выполнения. Как будто их нет. В конце
концов, универсальная реализация, например, класса коллекции в любом случае будет работать с любым типом входных данных.</p>

<p>Таким образом, если мы будем игнорировать проверки общих типов во время выполнения, проблем не возникнет.</p>

<p>Но не спешите. Игнорирование общих типов во время выполнения — это, кстати, называется <strong>затиранием типов</strong> в Java и
Python, создаёт некоторые проблемы в PHP.</p>

<p>Во-первых, PHP не только использует типы для проверки, он также использует информацию о типах для преобразования
значений на лету из одного типа в другой — жонглирование типами, о котором я упоминал в <a href="/post/generics-in-php/">первой статье</a> этой серии:</p>

<pre><code class="language-php">&lt;?php

function add(int $a, int $b): int 
{
    return $a + $b;
}

add('1', '2') // 3;
</code></pre>

<p>Если бы PHP проигнорировал общий тип этой «строковой» коллекции и мы случайно добавили бы к ней целое число, он не смог
бы нас об этом предупредить, если бы общий тип был затёрт:</p>

<pre><code class="language-php">&lt;?php

$slugs = new Collection&lt;string&gt;();

$slugs[] = 1; // 1 не будет приведено к '1'
</code></pre>

<p>Вторая и более важная проблема с затиранием типов, возможно, вы уже догадались, заключается в том,
что типы исчезают. Зачем нам добавлять общие типы, если они затираются во время выполнения?</p>

<p>Есть смысл делать это в Java и Python, потому что все определения типов проверяются перед запуском кода с помощью статического
анализатора. Java, например, запускает встроенный статический анализатор во время компиляции кода, то, чего PHP просто не
делает: нет шага компиляции и уж точно нет встроенного статического анализатора типов.</p>

<p>С другой стороны... все преимущества проверки типов, о которых мы говорили в предыдущих статьях, не берутся из
встроенного в PHP средства проверки типов во время выполнения. К тому времени, когда средство проверки типов PHP
сообщает нам, что что-то не так, мы уже выполняем код. Ошибка типа приведёт к сбою программы.</p>

<p>Вместо этого, большая часть дополнительной ценности проверок типов исходит от статических анализаторов, которые не
требуют запуска кода. Они довольно хорошо проверяют, не может ли быть ошибок типов во время выполнения, если вы,
программист, предоставите достаточно информации о типах. Это не означает, что в вашем коде не может быть ошибок, но
вполне возможно написать PHP-код, который полностью статически проверен и не выдаст никаких ошибок типа во время
выполнения.</p>

<p>Более того, статическая информация, которую мы получаем при написании кода, является самой ценной частью любой системы
типов и не имеет ничего общего с проверкой типов во время выполнения.</p>

<p>Так нужны ли нам проверки типов во время выполнения? Потому что это основная причина, по которой дженерики не могут быть
добавлены в PHP сегодня — это либо слишком сложно, либо слишком ресурсоёмко для PHP, чтобы проверять дженерики во время
выполнения.</p>

<p>Об этом в следующий раз, в последней статье этой серии.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/generics-in-depth</link>
    <pubDate>Fri, 01 Apr 2022 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Погружаемся в дженерики</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/generics-in-depth/cover.jpg">
            </figure>
        </header>
        <h1>Погружаемся в дженерики</h1>

<p>В <a href="/post/generics-in-php/">предыдущей статье</a> мы рассмотрели довольно скучный пример дженериков, в этой статье давайте рассмотрим примеры получше.</p>

<pre><code class="language-php">&lt;?php

$users = new Collection&lt;User&gt;();

$slugs = new Collection&lt;string&gt;();
</code></pre>

<p>Коллекции — пожалуй, самый простой способ объяснить, что такое дженерики, когда обсуждают дженерики, коллекции часто приводятся в пример.
На самом деле нередко люди думают, что "дженерики" и "коллекции с указанием типа" — одно и то же. Это определённо не так.</p>

<p>Итак, давайте рассмотрим ещё два примера.</p>

<p>Функция <code>app</code> — если вы работаете с фреймворком Laravel, она может показаться вам знакомой:
функция принимает имя класса и возвращает экземпляр этого класса, используя контейнер зависимостей:</p>

<pre><code class="language-php">&lt;?php

function app(string $className): mixed
{
    return Container::get($className);
}
</code></pre>

<p>Вам не нужно знать, как работает контейнер, важно то, что функция возвращает экземпляр класса, который вы запросили.</p>

<p>Так что, по сути, это дженериковая функция, у которой возвращаемый тип зависит от передаваемого имени класса.</p>

<p>Было бы здорово, если бы IDE и другие статические анализаторы также понимали, что при передаче функции имени класса <code>UserRepository</code>,
мы ожидаем возвращения экземпляра <code>UserRepository</code> и ничего больше:</p>

<pre><code class="language-php">&lt;?php

function app(string $className): mixed
{ /* … */ }

app(UserRepository::class); // ?
</code></pre>

<p>Дженерики позволяют нам это сделать.</p>

<p>Думаю, сейчас самое время упомянуть, что я немного слукавил: <a href="/post/generics-in-php/">ранее я говорил</a>, что в PHP дженериков не существуют, но это не совсем так.</p>

<p>Все статические анализаторы — инструменты, которые читают код, не запуская, инструменты вроде IDE — согласились использовать для дженериков Docblock-аннотацию:</p>

<pre><code class="language-php">/**
 * @template Type
 * @param class-string&lt;Type&gt; $className
 * @return Type
 */
function app(string $className): mixed
{ /* … */ }
</code></pre>

<p>Согласен, это не самый красивый синтаксис и все статические анализаторы полагаются на простое соглашение — официальной спецификации нет;
тем не менее, это работает.</p>

<p>PhpStorm, Psalm и PhpStan — три крупнейших статических анализатора в мире PHP — в той или иной степени понимают этот синтаксис.</p>

<p>IDE, такие как PhpStorm, используют его для обратной связи с программистом во время написания кода, а инструменты, такие как Psalm и PhpStan,
используют его для массового анализа вашей кодовой базы и обнаружения потенциальных ошибок, преимущественно на основе объявления типов.</p>

<p>Так что на самом деле мы можем реализовать эту функцию, чтобы наши инструменты больше не работали вслепую.</p>

<p>Непосредственно PHP не гарантирует, что возвращаемый тип будет правильным — PHP делает никаких проверок типа во время выполнения этой функции,
но если мы можем доверять нашим статическим анализаторам, то вероятность того, что этот код сломается во время выполнения, очень мала, а то и вовсе отсутствует.</p>

<p>В этом заключается невероятная сила статического анализа: мы можем быть уверены, что, не запуская код, большая его часть будет работать так, как задумано.</p>

<p>И всё это благодаря типам, включая дженерики.</p>

<p>Давайте рассмотрим более сложный пример:</p>

<pre><code class="language-php">&lt;?php

Attributes::in(MyController::class)
    -&gt;filter(RouteAttribute::class)
    -&gt;newInstance()
    -&gt;
</code></pre>

<p>У нас есть класс, который может "запрашивать" атрибуты и создавать их на лету.</p>

<p>Если вы уже работали с атрибутами, то знаете, что Reflection API довольно многословен, поэтому такой класс-помощник будет весьма полезен.</p>

<p>Как вы уже догадались, дженерики позволяют нам сделать это:</p>

<p>При использовании метода <code>filter</code>, задаётся имя класса атрибута и после вызова метода <code>newInstance</code>,
результатом будет экземпляр отфильтрованного класса. И снова, было бы неплохо, если бы наша IDE понимала, о чём мы говорим.</p>

<p>Как вы уже догадались, дженерики позволяют нам это сделать:</p>

<pre><code class="language-php">&lt;?php

/** @template AttributeType */
class Attributes
{
    /**
     * @template InputType
     * @param class-string&lt;InputType&gt; $className
     * @return self&lt;InputType&gt;
     */
    public function filter(string $className): self
    { /* … */ }

    /**
     * @return AttributeType 
     */   
    public function newInstance(): mixed
    { /* … */ }

    // …
}
</code></pre>

<p>Надеюсь, вы начинаете понимать, насколько мощной может быть простая информация о типе.
Пару лет назад мне потребовался бы плагин для IDE, чтобы подобные вещи заработали, теперь же мне просто нужно добавить информацию о типе.</p>

<p>Однако в последнем примере показаны не только на дженерики, есть ещё одна не менее важная составляющая.</p>

<p>Вывод типа: способность статического анализатора «угадывать» или надёжно определять тип без указания его пользователем.</p>

<p>Именно это происходит с аннотацией <code>class-string</code>. IDE способна распознать входные данные, которые передаются функции,
как имя класса и вывести этот тип в качестве типа с дженериком.</p>

<p>Итак, подытожим: дженерики доступны в PHP и все основные статические анализаторы знают, как с ними работать. Но... есть пара оговорок.</p>

<p>Во-первых, не существует официальной спецификации того, как должны выглядеть дженерики, прямо сейчас каждый статический анализатор может использовать свой собственный синтаксис;
на данный момент они пришли к единому соглашению, но нет никаких гарантий, что так и останется в будущем.</p>

<p>Во-вторых, Docblock-аннотации, на мой взгляд, неоптимальные. Они ощущаются как незначительная часть кодовой базы.
И да, аннотации дженериков предоставляют только статическую информацию, без проверки типов во время выполнения, но мы увидели,
насколько мощным может быть статический анализ, даже без такой проверки.</p>

<p>Я думаю, что несправедливо относиться к информации о типах как к «doc-комментариям» — они не передают важности типов в нашем коде.
Именно поэтому в PHP 8 появились атрибуты: все возможности, которые открывают атрибуты, уже были возможны с помощью Docblock-аннотаций,
но эта реализация была недостаточно хороша. То же самое относится и к дженерикам.</p>

<p>И наконец, без соответствующей спецификации у всех трёх основных статических анализаторов есть различия в реализации дженериков.
В идеале, должна быть официальная спецификация, исходящая от внутренних разработчиков PHP. Сейчас её нет.</p>

<p>Это основные причины, по которым я считаю, что стоит инвестировать время в более постоянное и устойчивое решение.</p>

<p>Так почему же в PHP до сих пор нет подходящих дженериков? Почему мы полагаемся на Docblock-аннотации без чёткой спецификации?</p>

<p>Об этом в <a href="/post/generics-why-we-cant-have-them/">следующей статье</a>.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/generics-in-php</link>
    <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Дженерики в PHP</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/generics-in-php/cover.jpg">
            </figure>
        </header>
        <h1>Дженерики в PHP</h1>

<p>Я хотел бы, чтобы они появились и знаю многих разработчиков, которые согласны со мной. С другой
стороны, есть группа PHP-программистов, возможно, даже большая, которые не знают, что такое дженерики и для чего они нужны.</p>

<p>Давайте поговорим о том, что такое дженерики, почему PHP не поддерживает их и что, возможно, нас ждёт в будущем.</p>

<p>У каждого языка программирования есть определённая система типов. У некоторых языков очень строгая реализация, в то
время как у других — PHP относится к этой категории — более слабая.</p>

<p>Системы типов используются по разным причинам, самая очевидная из них — <strong>проверка типов</strong>.</p>

<p>Представим, что у нас есть функция, которая принимает два числа, два целых числа и выполняет некоторую математическую
операцию:</p>

<pre><code class="language-php">&lt;?php

function add($a, $b) 
{
    return $a + $b;
}
</code></pre>

<p>PHP с радостью позволит вам передавать в эту функцию любые данные: числа, строки, логические значения — неважно. PHP изо
всех сил постарается преобразовать переменную, когда в этом есть смысл, например, в случае сложения.</p>

<pre><code class="language-php">&lt;?php

add('1', '2'); // 3
</code></pre>

<p>Но эти преобразования — жонглирование типами — часто приводят к неожиданным результатам, если не сказать, что к ошибкам
и сбоям.</p>

<pre><code class="language-php">&lt;?php

add([], true); // ?
</code></pre>

<p>Можно добавить проверку, чтобы функция работала с любыми входными данными:</p>

<pre><code class="language-php">&lt;?php

function add($a, $b) 
{
    if (!is_int($a) || !is_int($b)) {
        return null;
    }

    return $a + $b;
}
</code></pre>

<p>Или можно использовать встроенные объявления типов PHP:</p>

<pre><code class="language-php">&lt;?php

function add(int $a, int $b): int 
{
    return $a + $b;
}
</code></pre>

<p>Многие разработчики в сообществе PHP не используют объявления типов, потому что знают, какие входные данные
передавать в функцию — в конце концов, они сами её написали.</p>

<p>Однако такие рассуждения быстро рассыпаются: зачастую вы не единственный, кто работает с этим кодом, вы также
используете код, который написан другими — подумайте о том, сколько composer-пакетов вы используете. Поэтому, хотя этот
пример в отдельности может показаться не таким уж важным, проверка типов действительно пригодится, когда кодовая база
начнёт расти.</p>

<p>Кроме того, добавление объявления типов не только защищает от недопустимого состояния, но и <strong>разъясняет</strong>, какие
входные данные от нас, программистов, ожидаются. Часто с типами данных вам не нужно читать внешнюю документацию, потому
что многое из того, что делает функция, уже заключено в объявлении типов.</p>

<p>IDE активно помогают в работе: они могут сообщить программисту, какой тип входных данных ожидает функция или какие поля
и методы доступны для объекта, который принадлежит к определённому классу. С помощью IDE, написание кода становится
более продуктивным, во многом потому, что они могут статически анализировать объявления типов по всей нашей кодовой
базе.</p>

<p>С другой стороны, у систем типов свои ограничения. Простой пример — список элементов:</p>

<pre><code class="language-php">&lt;?php

class Collection extends ArrayObject
{
    public function offsetGet(mixed $key): mixed 
    { /* … */ }

    public function filter(Closure $fn): self 
    { /* … */ }

    public function map(Closure $fn): self 
    { /* … */ }
}
</code></pre>

<p>У коллекции множество методов, которые работают с любыми типами входных данных: цикл, фильтрация, сопоставление — что
угодно; коллекции должно быть не важно, имеет ли она дело со строками или целыми числами.</p>

<p>Но давайте посмотрим на это с точки зрения стороннего наблюдателя. Что произойдёт, если мы хотим быть уверены, что одна
коллекция содержит только строки, а другая — только объекты <code>User</code>. Коллекцию не волнует тип данных при переборе
элементов, но нас волнует. Мы хотим знать, является ли данный элемент в цикле пользователем или строкой — это большая
разница. Но без надлежащей информации о типах данных, IDE не сможет эффективно подсказывать нам во время работы.</p>

<pre><code class="language-php">&lt;?php

$users = new Collection();

// …

foreach ($users as $user) {
    $user-&gt; // ?
}
</code></pre>

<p>Мы могли бы создать отдельные реализации для каждой коллекции: одна работает только со строками, а другая — только с
объектами <code>User</code>:</p>

<pre><code class="language-php">&lt;?php

class StringCollection extends Collection
{
    public function offsetGet(mixed $key): string 
    { /* … */ }
}

class UserCollection extends Collection
{
    public function offsetGet(mixed $key): User 
    { /* … */ }
}
</code></pre>

<p>Но что, если нам понадобится третья реализация? Четвёртая? Может быть, десятая или двадцатая. Управлять этим кодом станет
довольно мучительно.</p>

<p>Вот тут-то и приходят на помощь дженерики.</p>

<p>Чтобы внести ясность: <strong>в PHP нет дженериков</strong>. То, что я покажу дальше, невозможно в PHP, но это возможно во многих других
языках.</p>

<p>Вместо того чтобы создавать отдельную реализацию для каждого возможного типа, многие языки программирования позволяют
разработчикам определять "общий" тип классу коллекции:</p>

<pre><code class="language-php">&lt;?php

class Collection&lt;Type&gt; extends ArrayObject
{
    public function offsetGet(mixed $key): Type 
    { /* … */ }

    // …
}
</code></pre>

<p>По сути, мы говорим, что реализация класса коллекции будет работать для любого типа входных данных, но когда мы создаём
экземпляр коллекции, мы должны указать этот тип. Общая реализация уточняется в зависимости от потребностей
программиста:</p>

<pre><code class="language-php">&lt;?php

$users = new Collection&lt;User&gt;();

$slugs = new Collection&lt;string&gt;();
</code></pre>

<p>Может показаться мелочью: добавить тип, но это открывает целый мир возможностей.</p>

<p>Теперь IDE знает, какие данные находятся в коллекции, может подсказать нам многое: не добавляем ли мы элемент с
неправильным типом; что мы можем делать с элементами при итерации коллекции; передаём ли мы коллекцию в функцию, которая
знает, как работать с этими конкретными элементами.</p>

<p>И хотя технически мы могли бы добиться того же самого, вручную реализуя коллекцию каждого необходимого нам типа, общая
реализация значительно упростит работу для нас, разработчиков, которые пишут и поддерживают код.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/php-81-readonly-properties</link>
    <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Свойства, доступные только для чтения в PHP 8.1</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/php-81-readonly-properties/cover.jpg">
            </figure>
        </header>
        <p>Написание <acronym title="Объект передачи данных">DTO</acronym> и <acronym title="Объект-значение">VO</acronym> на PHP с
годами стало значительно проще. Взгляните, например, на DTO в PHP 5.6:</p>

<pre><code class="language-php">class BlogData
{
    /** @var string */
    private $title;

    /** @var Status */
    private $status;

    /** @var \DateTimeImmutable|null */
    private $publishedAt;

    /**
     * @param string $title
     * @param Status $status
     * @param \DateTimeImmutable|null $publishedAt
     */
    public function __construct(
        $title,
        $status,
        $publishedAt = null
    ) {
        $this-&gt;title = $title;
        $this-&gt;status = $status;
        $this-&gt;publishedAt = $publishedAt;
    }

    /**
     * @return string
     */
    public function getTitle()
    {
        return $this-&gt;title;
    }

    /**
     * @return Status
     */
    public function getStatus()
    {
        return $this-&gt;status;
    }

    /**
     * @return \DateTimeImmutable|null
     */
    public function getPublishedAt()
    {
        return $this-&gt;publishedAt;
    }
}
</code></pre>

<p>И сравните с аналогом в PHP 8.0:</p>

<pre><code class="language-php">class BlogData
{
    public function __construct(
        private string $title,
        private Status $status,
        private ?DateTimeImmutable $publishedAt = null,
    ) {
    }

    public function getTitle(): string
    {
        return $this-&gt;title;
    }

    public function getStatus(): Status
    {
        return $this-&gt;status;
    }

    public function getPublishedAt(): ?DateTimeImmutable
    {
        return $this-&gt;publishedAt;
    }
}
</code></pre>

<p>Видна огромная разница, хотя я думаю, что есть ещё одна большая проблема: все эти методы чтения. Лично я их больше не
использую, начиная с PHP 8.0, в котором добавили определение свойств в конструкторе. Я предпочитаю использовать
общедоступные свойства вместо написания методов чтения:</p>

<pre><code class="language-php">class BlogData
{
    public function __construct(
        public string $title,
        public Status $status,
        public ?DateTimeImmutable $publishedAt = null,
    ) {
    }
}
</code></pre>

<p>Однако объектно-ориентированным пуристам такой подход не нравится: внутренний статус объекта не должен быть раскрыт
напрямую и определённо не может быть изменён извне.</p>

<p>В наших проектах в Spatie есть внутреннее руководство по написанию кода, согласно которому DTO и VO с общедоступными
свойствами не должны изменяться извне. Подход, который, кажется, работает вполне неплохо, мы используем его уже довольно
давно, не сталкиваясь с какими-либо проблемами.</p>

<p>Однако да, я согласен с тем, что было бы лучше, если бы язык гарантировал, что общедоступные свойства вообще не могут
быть переопределены. Что ж, в PHP 8.1 решили эту проблему, добавив ключевое слово <code>readonly</code>:</p>

<pre><code class="language-php">class BlogData
{
    public function __construct(
        public readonly string $title,
        public readonly Status $status,
        public readonly ?DateTimeImmutable $publishedAt = null,
    ) {
    }
}
</code></pre>

<p>Как и предполагает его название, смысл ключевого слова в том, что после того, как свойство установлено, его больше
нельзя переопределить:</p>

<pre><code class="language-php">$blog = new BlogData(
    title: 'PHP 8.1: readonly-свойства',
    status: Status::PUBLISHED,
    publishedAt: now()
);

$blog-&gt;title = 'Какой-то другой заголовок'; // Ошибка: Нельзя переопределить свойство, доступное только для чтения BlogData::$title
</code></pre>

<p>Знание, что когда объект инициализирован, он больше не будет меняться, даёт нам определённый уровень уверенности и
спокойствия при написании кода: целый ряд непредвиденных изменений данных просто не может произойти.</p>

<p>Конечно, по-прежнему нужна возможность клонировать объект и, возможно, изменять некоторые свойства в процессе. Далее мы
обсудим, как это сделать со свойствами, доступными только для чтения. Для начала, давайте рассмотрим их подробнее.</p>

<h2>Только типизированные свойства</h2>

<p>Свойства, доступные только для чтения могут быть только типизированными:</p>

<pre><code class="language-php">class BlogData
{
    public readonly string $title;

    public readonly $mixed; // Ошибка: Нельзя использовать не типизированное свойство, доступное только для чтения
}
</code></pre>

<p>Однако вы можете использовать тип <code>mixed</code> для указания типа:</p>

<pre><code class="language-php">class BlogData
{
    public readonly string $title;

    public readonly mixed $mixed;
}
</code></pre>

<p>Причина этого ограничения заключается в том, что, опуская тип свойства, PHP автоматически устанавливает значение <code>null</code>,
если в конструкторе не было определено явное значение. Такое поведение в сочетании со свойствами, доступными только для чтения вызовет ненужную
путаницу.</p>

<h2>Обычные объекты и объекты с определением свойств в конструкторе</h2>

<p>Вы уже видели примеры и того и другого: <code>readonly</code> можно добавить как к обычному, так и к свойству, определяемому в
конструкторе:</p>

<pre><code class="language-php">class BlogData
{
    public readonly string $title;

    public function __construct(
        public readonly Status $status, 
    ) {}
}
</code></pre>

<h2>Нет значения по умолчанию</h2>

<p>У readonly-свойств не может быть значения по умолчанию:</p>

<pre><code class="language-php">class BlogData
{
    public readonly string $title = 'Readonly-свойства'; // Ошибка: Нельзя использовать значение по умолчанию
}
</code></pre>

<p>Точнее, если это не свойство, определяемое в конструкторе:</p>

<pre><code class="language-php">class BlogData
{
    public function __construct(
        public readonly string $title = 'Readonly-свойства', 
    ) {}
}
</code></pre>

<p>Причина, по которой это разрешено для свойств, определяемых в конструкторе, заключается в том, что значение по умолчанию
в этом случае используется не в качестве значения по умолчанию для свойства класса, а только для аргумента конструктора.
Под капотом приведённый выше код будет преобразован в этот:</p>

<pre><code class="language-php">class BlogData
{
    public readonly string $title;

    public function __construct(
        string $title = 'Readonly-свойства', 
    ) {
        $this-&gt;title = $title;
    }
}
</code></pre>

<p>Посмотрите, как фактическому свойству не присваивается значение по умолчанию. Причина запрета использования значений по
умолчанию для свойств, доступных только для чтения, заключается в том, что в таком виде они ничем не будут отличаться от констант.</p>

<h2>Наследование</h2>

<p>Нельзя изменять флаг <code>readonly</code> при наследовании:</p>

<pre><code class="language-php">class Foo
{
    public readonly int $prop;
}

class Bar extends Foo
{
    public int $prop; // Ошибка: Нельзя изменять флаг readonly
}
</code></pre>

<p>Правило действует в обоих направлениях: вам не разрешено добавлять или удалять флаг <code>readonly</code> при наследовании.</p>

<h2>Unset не допускается</h2>

<p>После того как свойство, доступное только для чтения, установлено, вы не можете его изменить и даже сбросить:</p>

<pre><code class="language-php">$foo = new Foo('value');

unset($foo-&gt;prop); // Ошибка: Нельзя сбросить readonly-свойство
</code></pre>

<h2>Reflection</h2>

<p>Добавлен новый метод <code>ReflectionProperty::isReadOnly()</code>, а также флаг <code>ReflectionProperty::IS_READONLY</code>.</p>

<h2>Клонирование</h2>

<p>Итак, если нельзя изменить свойство, доступные только для чтения, и, если нельзя их сбросить, каким образом можно создать копию своих DTO
или VO и изменить какие-то данные? Также нельзя использовать <code>clone</code>, потому что вы не сможете перезаписать их значения.</p>

<p>На самом деле есть идея добавить в будущем конструкцию <code>clone with</code>, которая допускает такое поведение, но сейчас
проблема не решена.</p>

<p>Что ж, можно клонировать объекты с изменёнными свойствами, доступными только для чтения, если полагаться на магию Reflection. Создавая объект
без вызова его конструктора (что возможно с помощью Reflection), а затем вручную копируя каждое свойство, иногда
перезаписывая значение, вы фактически можете «клонировать» объект и изменить его свойства, доступные только для чтения.</p>

<p>Для этого я разработал <a href="https://github.com/spatie/php-cloneable">небольшой пакет</a>, вот как он выглядит:</p>

<pre><code class="language-php">class BlogData
{
    use Cloneable;

    public function __construct(
        public readonly string $title,
    ) {}
}

$dataA = new BlogData('Title');

$dataB = $dataA-&gt;with(title: 'Another title');
</code></pre>

<p>Также я написал <a href="https://stitcher.io/blog/cloning-readonly-properties-in-php-81">специальный пост</a> в блоге, объясняющий
всю механику.</p>

<p>Вот и всё, что можно сказать о свойствах, доступных только для чтения. Я думаю, что это отличная возможность, при работе над проектами со
множеством DTO и VO и требующими от вас тщательного управления потоком данных во всем коде. Неизменяемые объекты со
свойствами, доступными только для чтения очень в этом помогут.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/php-81-enums</link>
    <pubDate>Mon, 02 Aug 2021 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Перечисления в PHP 8.1</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/php-81-enums/cover.jpg">
            </figure>
        </header>
        <p>Они наконец-то появятся: поддержка перечислений будет добавлена в PHP 8.1!
Пост посвящён более подробному рассмотрению нового функционала.</p>

<p>Начнём с того, как выглядят перечисления:</p>

<pre><code class="language-php">enum Status
{
    case DRAFT;
    case PUBLISHED;
    case ARCHIVED;
}
</code></pre>

<p>Преимущество перечислений заключается в том, что они представляют собой набор постоянных значений,
но, что наиболее важно, эти значения можно использовать следующим образом:</p>

<pre><code class="language-php">class BlogPost
{
    public function __construct(
        public Status $status,
    ) {}
}
</code></pre>

<p>В примере выше создание <code>BlogPost</code> и передача в него перечисления выглядит так:</p>

<pre><code class="language-php">$post = new BlogPost(Status::DRAFT);
</code></pre>

<p>Не будем останавливаться на основах, поскольку, как вы уже заметили, в этом нет ничего сложного.
Однако, есть ещё много дополнительных возможностей, давайте рассмотрим перечисления подробнее!</p>

<h2>Методы перечислений</h2>

<p>Перечисления могут определять методы, как и обычные классы. Это очень удобно, особенно в сочетании с оператором <code>match</code>:</p>

<pre><code class="language-php">enum Status
{
    case DRAFT;
    case PUBLISHED;
    case ARCHIVED;

    public function color(): string
    {
        return match($this) 
        {
            Status::DRAFT =&gt; 'grey',   
            Status::PUBLISHED =&gt; 'green',   
            Status::ARCHIVED =&gt; 'red',   
        };
    }
}
</code></pre>

<p>Методы можно использовать так:</p>

<pre><code class="language-php">$status = Status::ARCHIVED;

$status-&gt;color(); // 'red'
</code></pre>

<p>Также можно использовать статичные методы:</p>

<pre><code class="language-php">enum Status
{
    // …

    public static function make(): Status
    {
        // …
    }
}
</code></pre>

<p>И использовать в перечислениях <code>self</code>:</p>

<pre><code class="language-php">enum Status
{
    // …

    public function color(): string
    {
        return match($this) 
        {
            self::DRAFT =&gt; 'grey',   
            self::PUBLISHED =&gt; 'green',   
            self::ARCHIVED =&gt; 'red',   
        };
    }
}
</code></pre>

<h2>Перечисления и интерфейсы</h2>

<p>Также как и классы, перечисления могут реализовывать интерфейсы:</p>

<pre><code class="language-php">interface HasColor
{
    public function color(): string;
}

enum Status implements HasColor
{
    case DRAFT;
    case PUBLISHED;
    case ARCHIVED;

    public function color(): string { /* … */ }
}
</code></pre>

<h2>Значения перечислений</h2>

<p>Хотя перечисления являются объектами, вы можете присвоить им значения, если пожелаете;
это может быть полезно, например, для сохранения их в базу данных.</p>

<pre><code class="language-php">enum Status: string
{
    case DRAFT = 'draft';
    case PUBLISHED = 'published';
    case ARCHIVED = 'archived';
}
</code></pre>

<p>Обратите внимание на объявление типа в определении перечисления. Он указывает на то, что все значения перечисления относятся к указанному типу.
Вы также можете сделать его <code>int</code>. В качестве типа можно использовать только <code>int</code> или <code>string</code>.</p>

<pre><code class="language-php">enum Status: int
{
    case DRAFT = 1;
    case PUBLISHED = 2;
    case ARCHIVED = 3;
}
</code></pre>

<p>Если вы решите присвоить значения перечислениям, это будет необходимо сделать для всех вариантов,
также нельзя смешивать и совмещать типы.</p>

<h2>Типизированные перечисления с интерфейсами</h2>

<p>Если вы используете типизированные перечисления совместно с интерфейсами, тип должен стоять сразу после имени перечисления,
перед ключевым словом <code>implements</code>.</p>

<pre><code class="language-php">enum Status: string implements HasColor
{
    case DRAFT = 'draft';
    case PUBLISHED = 'published';
    case ARCHIVED = 'archived';

    // …
}
</code></pre>

<h2>Сериализация типизированных перечислений</h2>

<p>Если вы присваиваете значения вариантам перечислений, вам, вероятно, понадобится способ их сериализации и десериализации.
Под сериализацией подразумевается, что вам нужен способ получить значение перечисления. Это делается с помощью общедоступного readonly-свойства:</p>

<pre><code class="language-php">$value = Status::PUBLISHED-&gt;value; // 2
</code></pre>

<p>Для получения перечисления по значению можно использовать метод <code>Enum::from</code>:</p>

<pre><code class="language-php">$status = Status::from(2); // Status::PUBLISHED
</code></pre>

<p>Также существует метод <code>tryFrom</code>, который возвращает <code>null</code>, если передано неизвестное значение.
При использовании <code>from</code> в таком случае, будет выброшено исключение.</p>

<pre><code class="language-php">$status = Status::from('unknown'); // ValueError
$status = Status::tryFrom('unknown'); // null
</code></pre>

<p>Обратите внимание, вы можете использовать встроенные функции <code>serialize</code> и <code>unserialize</code> при работе c перечислениями.
Кроме того, вы можете использовать <code>json_encode</code> в сочетании с типизированными перечислениями, результатом выполнения функции будет значение перечисления.
Поведение можно переопределить, реализовав <code>JsonSerializable</code>.</p>

<h2>Вывод вариантов перечисления</h2>

<p>Чтобы получить список всех доступных вариантов перечисления, воспользуйтесь статичным методом <code>Enum::cases()</code>:</p>

<pre><code class="language-php">Status::cases();

/* [
Status::DRAFT,
Status::PUBLISHED,
Status::ARCHIVED
] */
</code></pre>

<p>Обратите внимание, что в массиве содержатся объекты перечислений:</p>

<pre><code class="language-php">array_map(
fn(Status $status) =&gt; $status-&gt;color(),
Status::cases()
);
</code></pre>

<h2>Перечисления — это объекты</h2>

<p>Я уже упоминал, что варианты перечислений являются объектами, на самом деле это одноэлементные объекты.
Вы можете сравнивать их следующим образом:</p>

<pre><code class="language-php">$statusA = Status::PENDING;
$statusB = Status::PENDING;
$statusC = Status::ARCHIVED;

$statusA === $statusB; // true
$statusA === $statusC; // false
$statusC instanceof Status; // true
</code></pre>

<h2>Перечисления как ключи массива</h2>

<p>Поскольку перечисления являются объектами, в настоящее время невозможно использовать их в качестве ключей массива.
Этот код приведёт к ошибке:</p>

<pre><code class="language-php">$list = [
Status::DRAFT =&gt; 'draft',
// …
];
</code></pre>

<p>В <a href="https://wiki.php.net/rfc/object_keys_in_arrays">RFC</a> от Никиты Попова предлагается изменение такого поведения, но он ещё не перешёл в стадию голосования.</p>

<p>Пока что вы можете использовать перечисления в качестве ключей только в <code>SplObjectStorage</code> и <code>WeakMaps</code>.</p>

<h2>Трейты</h2>

<p>Перечисления могут использовать трейты так же, как классы, но с некоторыми ограничениями:
нельзя переопределять встроенные методы перечислений, а также трейты не могут содержать свойства класса — в перечислениях свойства запрещены.</p>

<h2>Reflection и атрибуты</h2>

<p>Как и ожидалось, добавлено несколько Reflection-классов для работы с перечислениями:
<code>ReflectionEnum</code>, <code>ReflectionEnumUnitCase</code> и <code>ReflectionEnumBackedCase</code>. Также появилась новая функция <code>enum_exists</code>, название которой говорит само за себя.</p>

<p>Как и обычные классы и свойства, перечисления и их варианты можно аннотировать с помощью атрибутов. Обратите внимание, перечисления будут включены в фильтр <code>TARGET_CLASS</code>.</p>

<p>И последнее: у перечислений также есть readonly-свойство <code>$enum-&gt;name</code>, которое в RFC упоминается как часть реализации и, вероятно, должно использоваться только для отладки.
Однако об этом всё же стоит упомянуть.</p>

<p>Вот и всё, что можно сказать о перечислениях. Я с нетерпением жду возможности использовать их, как только выйдет PHP 8.1.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/php-81-before-and-after</link>
    <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>PHP 8.1 до и после</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/php-81-before-and-after/cover.jpg">
            </figure>
        </header>
        <p><a href="https://wiki.php.net/todo/php81">PHP 8.1</a> выйдет через несколько месяцев и я в восторге от множества нововведений!
Хочу поделиться реальным влиянием PHP 8.1 на мой собственный код.</p>

<h2>Перечисления</h2>

<p>Долгожданный функционал, перечисления скоро будут доступны!</p>

<p>О них можно сказать не так много, кроме того, что я с нетерпением жду, когда мне больше не придётся использовать <a href="https://github.com/spatie/enum">spatie/enum</a> или <a href="https://github.com/myclabs/php-enum">myclabs/php-enum</a>.
Спасибо за все годы поддержки этих enum-пакетов, но они будут первыми, от которых я откажусь, когда появится PHP 8.1 и когда я изменю это:</p>

<pre><code class="language-php">/**
 * @method static self draft()
 * @method static self published()
 * @method static self archived()
 */
class StatusEnum extends Enum
{
}
</code></pre>

<p>На это:</p>

<pre><code class="language-php">enum Status
{
    case draft;
    case published;
    case archived;
}
</code></pre>

<h2>Распаковка массивов со строковыми ключами</h2>

<p>Может показаться незначительным, но меня это не раз беспокоило: до PHP 8.1 можно было распаковывать только массивы с числовыми ключами:</p>

<pre><code class="language-php">$a = [1, 2, 3];
$b = [4, 5, 6];

// Доступно, начиная с PHP 7.4
$new = [...$a, ...$b];
</code></pre>

<p>В то время как массивы со строковыми ключами распаковать таким образом было нельзя:</p>

<pre><code class="language-php">$a = ['a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 3];
$b = ['d' =&gt; 4, 'e' =&gt; 5, 'f' =&gt; 6];

$new = [...$a, ...$b]; 

// В этом случае необходимо использовать array_merge
$new = array_merge($a, $b);
</code></pre>

<p>Итак, одна из особенностей PHP 8.1, которая облегчит мне жизнь, заключается в том, что теперь можно также распаковывать массивы со строковыми ключами!</p>

<h2>Свойства класса: инициализаторы и readonly</h2>

<p>Ещё одно замечательное улучшение, которое я ждал годами: аргументы по умолчанию в параметрах функции. Представьте, что вы хотите установить класс состояния по умолчанию для объекта <code>BlogData</code>. До PHP 8.1 вам необходимо было объявить его допускающим значение <code>null</code> и установить в конструкторе:</p>

<pre><code class="language-php">class BlogData
{
    public function __construct(
        public string $title,
        public ?BlogState $state = null,
    ) {
        $this-&gt;state ??= new Draft();
    }
}
</code></pre>

<p>PHP 8.1 позволяет вызов new непосредственно в определении функции. Это потрясающе:</p>

<pre><code class="language-php">class BlogData
{
    public function __construct(
        public string $title,
        public BlogState $state = new Draft(),
    ) {
    }
}
</code></pre>

<p>Говоря о грандиозных нововведениях, я уже упоминал, что readonly-свойства теперь стали явью?!?</p>

<pre><code class="language-php">class BlogData
{
    public function __construct(
        public readonly string $title,
        public readonly BlogState $state = new Draft(),
    ) {
    }
}
</code></pre>

<p>Да, кстати, не беспокойтесь о клонировании, <a href="https://stitcher.io/blog/cloning-readonly-properties-in-php-81">я о вас позаботился</a>.</p>

<h2>Callback-функции как объекты первого класса</h2>

<p>Как будто всего этого было недостаточно, теперь также доступны callback-функции как объекты первого класса, которые позволяют использовать более чистый код для создания замыканий из вызываемых объектов.</p>

<p>Раньше приходилось писать что-то вроде этого:</p>

<pre><code class="language-php">$strlen = Closure::fromCallable('strlen');
$callback = Closure::fromCallable([$object, 'method']);
</code></pre>

<p>В PHP 8.1 вы можете написать… так:</p>

<pre><code class="language-php">$strlen = strlen(...);
$callback = $object-&gt;method(...);
</code></pre>

<p>В PHP 8.1 есть ещё <a href="https://stitcher.io/blog/new-in-php-81">много нового</a>, но это то, что меня волнует больше всего.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/bitrix-third-party-components</link>
    <pubDate>Thu, 19 Nov 2020 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Правообладатели в 1С-Битрикс</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/bitrix-third-party-components/cover.jpg">
            </figure>
        </header>
        <h1>Правообладатели</h1>

<p>Начиная с версии <code>20.100.0</code> Главного модуля появилась страница «Правообладатели» (<code>/bitrix/admin/copyright.php</code>).</p>

<p>На ней перечислены лицензии используемых компонентов.</p>

<p><img src="/assets/images/posts/bitrix-third-party-components/1.png" alt="" /></p>

<h2>Добавление собственного компонента</h2>

<p>Чтобы добавить свой компонент в список, необходимо зарегистрировать обработчик события:</p>

<pre><code class="language-php">&lt;?php 

use Bitrix\Main\EventManager;
use Bitrix\Main\EventResult;
use Bitrix\Main\UI\Copyright;

$eventManager = EventManager::getInstance();
$eventManager-&gt;addEventHandler(
    'main',
    'onGetThirdPartySoftware',
    function () {
        return new EventResult(
            EventResult::SUCCESS, [
                (new Copyright('Модуль интеграции с Тинькофф'))
                    -&gt;setProductUrl('https://github.com/saundefined/tinkoff-sdk')
                    -&gt;setCopyright("Copyright 2020, Sergey Panteleev")
                    -&gt;setLicence(Copyright::LICENCE_MIT)
                    -&gt;setLicenceUrl('https://github.com/saundefined/tinkoff-sdk/blob/master/LICENSE.md'),

                (new Copyright('Модуль СМС-сервисы'))
                    -&gt;setProductUrl('https://github.com/qq-agency/ps.sms')
                    -&gt;setCopyright("Copyright 2020, QQ")
                    -&gt;setLicence(Copyright::LICENCE_MIT)
                    -&gt;setLicenceUrl('https://github.com/qq-agency/ps.sms/blob/master/LICENSE.md'),
            ]
        );
    }
);
</code></pre>

<p><img src="/assets/images/posts/bitrix-third-party-components/2.png" alt="" /></p>

<h2>Допустимые лицензии</h2>

<table>
<thead>
<tr>
  <th align="left">Лицензия</th>
  <th align="left">Константа</th>
</tr>
</thead>
<tbody>
<tr>
  <td align="left">MIT</td>
  <td align="left"><code>Copyright::LICENCE_MIT</code></td>
</tr>
<tr>
  <td align="left">Commercial</td>
  <td align="left"><code>Copyright::LICENCE_COMMERCIAL</code></td>
</tr>
<tr>
  <td align="left">Public Domain</td>
  <td align="left"><code>Copyright::LICENCE_PUBLIC_DOMAIN</code></td>
</tr>
<tr>
  <td align="left">2-Clause BSD</td>
  <td align="left"><code>Copyright::LICENCE_BSD2</code></td>
</tr>
<tr>
  <td align="left">3-Clause BSD</td>
  <td align="left"><code>Copyright::LICENCE_BSD3</code></td>
</tr>
<tr>
  <td align="left">Apache License, Version 2.0</td>
  <td align="left"><code>Copyright::LICENCE_APACHE2</code></td>
</tr>
<tr>
  <td align="left">W3C License</td>
  <td align="left"><code>Copyright::LICENCE_W3C</code></td>
</tr>
<tr>
  <td align="left">General Public License, version 2</td>
  <td align="left"><code>Copyright::LICENSE_GPLV2</code></td>
</tr>
<tr>
  <td align="left">Пользовательская лицензия</td>
  <td align="left"><code>Copyright::LICENCE_CUSTOM</code></td>
</tr>
</tbody>
</table>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/bitrix-sms</link>
    <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>СМС-сервисы в 1С-Битрикс</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/bitrix-sms/cover.jpg">
            </figure>
        </header>
        <p>Начиная с версии <code>18.5.0</code> в 1С-Битрикс добавлена поддержка штатной авторизации, регистрации и восстановления пароля с помощью СМС.</p>

<p>Из коробки на данный момент поддерживаются следующие сервисы: Компания SMS.RU, SMS-ассистент, Компания Twilio.com.</p>

<p>Если вы используете одну из этих компаний, обновите систему до необходимой версии,
установите модуль Служба сообщений, укажите данные для подключения к СМС-сервису в настройках <strong>Главного модуля</strong> и у вас должно появиться следующее:</p>

<p><img src="/assets/images/posts/bitrix-sms/1.png" alt="" /></p>

<h2>Добавление СМС-сервиса</h2>

<p>Для добавления собственного СМС-сервиса, начала необходимо создать класс, который будет наследовать
<code>Bitrix\MessageService\Sender\Base</code>, с обязательными методами:</p>

<table>
<thead>
<tr>
  <th>Метод</th>
  <th align="center">Возвращаемое значение</th>
  <th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
  <td>getShortName()</td>
  <td align="center">string</td>
  <td>Сокращённое наименование сервиса (например, домен)</td>
</tr>
<tr>
  <td>getId()</td>
  <td align="center">string</td>
  <td>Символьный код сервиса</td>
</tr>
<tr>
  <td>getName()</td>
  <td align="center">string</td>
  <td>Полное наименование сервиса (будет выводиться во всех списках)</td>
</tr>
<tr>
  <td>canUse()</td>
  <td align="center">boolean</td>
  <td>Если <code>false</code> – сервис не будет выводиться</td>
</tr>
<tr>
  <td>getFromList()</td>
  <td align="center">array</td>
  <td>Список подтверждённых имён отправителя</td>
</tr>
<tr>
  <td>sendMessage()</td>
  <td align="center"><code>Bitrix\MessageService\Sender\Result\SendMessage</code></td>
  <td>Реализация отправки сообщения</td>
</tr>
</tbody>
</table>

<p>Примерный код для добавления собственного СМС-сервиса:</p>

<pre><code class="language-php">&lt;?php

namespace Ps\Sms\Provider;

use Bitrix\Main\Error;
use Bitrix\MessageService\Sender\Base;
use Bitrix\MessageService\Sender\Result\SendMessage;

class MyService extends Base
{
    private $login;

    private $password;

    private $client;

    public function __construct() {
        $this-&gt;login = 'login';
        $this-&gt;password = 'my_strong_password';

        $this-&gt;client = new Api($this-&gt;login, $this-&gt;password);
    }

    public function sendMessage(array $messageFields) {
        if (!$this-&gt;canUse()) {
            $result = new SendMessage();
            $result-&gt;addError(new Error('Ошибка отправки. СМС-сервис отключён'));
            return $result;
        }

        $parameters = [
            'phones' =&gt; $messageFields['MESSAGE_TO'],
            'message' =&gt; $messageFields['MESSAGE_BODY'],
        ];

        if ($messageFields['MESSAGE_FROM']) {
            $parameters['sender'] = $messageFields['MESSAGE_FROM'];
        }

        $result = new SendMessage();
        $response = $this-&gt;client-&gt;send($parameters);

        if (!$response-&gt;isSuccess()) {
            $result-&gt;addErrors($response-&gt;getErrors());
            return $result;
        }

        return $result;
    }

    public function getShortName() {
        return 'smsc.ru';
    }

    public function getId() {
        return 'smscru';
    }

    public function getName() {
        return 'SMS-центр';
    }

    public function canUse() {
        return true;
    }

    public function getFromList() {
        $data = $this-&gt;client-&gt;getSenderList();
        if ($data-&gt;isSuccess()) {
            return $data-&gt;getData();
        }

        return [];
    }
}
</code></pre>

<p>Зарегистрируйте класс в качестве обработчика события:</p>

<pre><code class="language-php">&lt;?php

$event = \Bitrix\Main\EventManager::getInstance();
$event-&gt;addEventHandler('messageservice', 'onGetSmsSenders', 'registerSmscService');

function registerSmscService() {
    return [
        // Класс СМС-сервиса
        new Ps\Sms\Provider\MyService(),
    ];
}
</code></pre>

<p>В настройках <strong>Главного модуля</strong> появится новый СМС-сервис:</p>

<p><img src="/assets/images/posts/bitrix-sms/2.png" alt="" /></p>

<h2>API</h2>

<h3>Отправка сообщения</h3>

<p>Отправка сообщения с СМС кодом подтверждения регистрации:</p>

<pre><code class="language-php">&lt;?php

$userId = 1;
$phone = \Bitrix\Main\UserPhoneAuthTable::normalizePhoneNumber('+79999999999');

\Bitrix\Main\UserPhoneAuthTable::add([
    'USER_ID' =&gt; $userId,
    'PHONE_NUMBER' =&gt; $phone,
]);

list($code, $phoneNumber) = \CUser::GeneratePhoneCode($userId);

$sms = new \Bitrix\Main\Sms\Event(
    'SMS_USER_CONFIRM_NUMBER', // SMS_USER_RESTORE_PASSWORD - для восстановления
    [
        'USER_PHONE' =&gt; $phoneNumber,
        'CODE' =&gt; $code,
    ]
);
$sms-&gt;send(true);
</code></pre>

<h3>Подтверждение номера телефона</h3>

<p>Подтверждение кода из СМС:</p>

<pre><code class="language-php">&lt;?php

$phoneRecord = \Bitrix\Main\UserPhoneAuthTable::getList([
    'filter' =&gt; [
        '=USER_ID' =&gt; 1
    ],
    'select' =&gt; ['USER_ID', 'PHONE_NUMBER', 'USER.ID', 'USER.ACTIVE'],
])-&gt;fetchObject();

if(!$phoneRecord) {
    // Ошибка. Пользователь не найден
}

$smsCode = 1111;

if(\CUser::VerifyPhoneCode($phoneRecord-&gt;getPhoneNumber(), $smsCode)) {
    if($phoneRecord-&gt;getUser()-&gt;getActive() &amp;&amp; !$USER-&gt;IsAuthorized()) {
        $USER-&gt;Authorize($userId);
    }

    return true;
}
</code></pre>

<h2>Пример</h2>

<p>Пример подключения СМС-сервисов sms16.ru, smsc.ru, mainsms.ru и некоторых других выложен на <a href="https://github.com/qq-agency/ps.sms">GitHub</a>.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/bitrix-ajax</link>
    <pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>AJAX-запросы в 1С-Битрикс</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/bitrix-ajax/cover.jpg">
            </figure>
        </header>
        <p>В версии <code>17.5.10</code> Главного модуля 1С-Битрикс появились нативные обработчики ajax-запросов у компонентов и модулей.</p>

<h2>Компоненты</h2>

<p>Пример простого компонента формы обратной связи:</p>

<pre><code class="language-php">&lt;?php

namespace Ps\Components;

use Bitrix\Main\Context;

class Feedback extends \CBitrixComponent
{
    public function sendMessage($post)
    {
        // отправляем данные
    }

    public function executeComponent()
    {
        $this-&gt;sendMessage($this-&gt;request-&gt;getPostList()-&gt;toArray());

        $this-&gt;includeComponentTemplate();
    }
}
</code></pre>

<p>Чтобы вызвать метод <code>sendMessage</code> в AJAX-запросе, раньше необходимо было создать файл <code>/local/ajax/send-message.php</code> с содержимым:</p>

<pre><code class="language-php">&lt;?php

use Bitrix\Main\Context;

require_once $_SERVER['DOCUMENT_ROOT'] . '/bitrix/modules/main/include/prolog_before.php';

\CBitrixComponent::includeComponentClass('ps:feedback');

$post = Context::getCurrent()-&gt;getRequest()-&gt;getPostList()-&gt;toArray();

$component = new \Ps\Components\Feedback();
$component-&gt;sendMessage($post);
</code></pre>

<p>И так для каждого запроса.</p>

<p>В обновлении, 1С-Битрикс добавили возможность обращаться к методам непосредственно из <code>javascript</code>. Для этого обновите класс компонента:</p>

<pre><code class="language-php">&lt;?php

namespace Ps\Components;

use Bitrix\Main\Engine\Contract\Controllerable;

class Feedback extends \CBitrixComponent implements Controllerable
{
    // Обязательный метод
    public function configureActions()
    {
       // Сброс фильтров по умолчанию (ActionFilter\Authentication и ActionFilter\HttpMethod)
       // Предустановленные фильтры находятся в папке /bitrix/modules/main/lib/engine/actionfilter/
        return [
            'sendMessage' =&gt; [ // Ajax-метод
                'prefilters' =&gt; [],
            ],
        ];
    }

    // Ajax-методы должны быть с постфиксом Action
    public function sendMessageAction($post)
    {
        // отправка данных
    }

    public function executeComponent()
    {
        $this-&gt;includeComponentTemplate();
    }
}
</code></pre>

<p>Теперь необходимо вызвать метод:</p>

<pre><code class="language-php">&lt;script&gt;
BX.ajax.runComponentAction('ps:feedback',
    'sendMessage', { // Вызывается без постфикса Action
      mode: 'class',
      data: {post: {name: 'Иван', message: 'Тестовое сообщение'}}, // ключи объекта data соответствуют параметрам метода
    })
    .then(function(response) {
      if (response.status === 'success') {
        // В случае успешного выполнения
      }
    });
&lt;/script&gt;
</code></pre>

<p>В <code>configureActions</code> можно задать предпроверку данных, например, чтобы метод был доступен только для авторизованных пользователей или только <code>PUT</code>-запросом:</p>

<pre><code class="language-php">public function configureActions()
{
    return [
        'sendMessage' =&gt; [
            'prefilters' =&gt; [
                new ActionFilter\Authentication,
                new ActionFilter\HttpMethod([
                    ActionFilter\HttpMethod::METHOD_PUT
                ])
            ],
        ],
    ];
}
</code></pre>

<p>Ответ на запрос всегда будет приходить в стандартизированном json-формате.</p>

<h2>Модули</h2>

<p>Замечание</p>

<p>Данный функционал для партнёрских модулей, содержащих в названии точку (<code>ps.module</code>) доступен с версии <code>18.1.1</code> Главного модуля.</p>

<p>В модулях также дали возможность для AJAX-запросов к методам. В корне модуля создайте файл <code>.settings.php</code> со следующим содержимым:</p>

<pre><code class="language-php">&lt;?php

return [
    'controllers' =&gt; [
        'value' =&gt; [
            'namespaces' =&gt; [
                // Ключ - неймспейс для ajax-классов,
                // api - приставка экшенов, о ней мы поговорим чуть позже
                '\\Ps\\Module\\Controller' =&gt; 'api',
            ],
        ],
        'readonly' =&gt; true,
    ],
];
</code></pre>

<p>В папке <code>/lib/</code> добавьте папку <code>controller</code> и в ней разместите классы:</p>

<pre><code class="language-php">&lt;?php

namespace Ps\Module\Controller;

use Bitrix\Main\Engine\Controller;

class Updater extends Controller
{
    public function applyAction()
    {
        $request = $this-&gt;getRequest();

        return ['response' =&gt; 'success'];
    }
}
</code></pre>

<p>Чтобы обратиться к методу <code>applyAction</code>, вызовите функцию:</p>

<pre><code class="language-php">// ps – префикс партнёра, отделяется двоеточием
// module – название модуля
// api – приставка из .settings.php
// updater.apply – название класса и метода без постфикса Action

BX.ajax.runAction('ps:module.api.updater.apply')
    .then(function() {
      // Код после выполнения экшена
    });
</code></pre>

<p>Таким образом, обращаться к методам модулей и компонентов с помощью AJAX-запросов стало намного проще.</p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/bitrix-js</link>
    <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>1С-Битрикс JS</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/bitrix-js/cover.jpg">
            </figure>
        </header>
        <p>Практически в каждом проекте требуются различные JS-библиотеки: от слайдеров и всплывающих окон, до сложных графиков.</p>

<p>Часто принимается решение использовать сторонние решения, но под капотом 1С-Битрикс припасено множество полезных функций.</p>

<h2>amCharts</h2>

<p>Проприетарная библиотека для построения различных графиков, лицензия на которую включена 1С-Битрикс любой редакции. Ознакомиться с видами графиков и кодом для построения можно на странице с <a href="https://www.amcharts.com/demos/">примерами</a>.</p>

<p>Подключение библиотеки amCharts в 1С-Битрикс осуществляется стандартным способом: <code>CJSCore::Init(['amcharts']);</code></p>

<p>Подключать библиотеку необходимо в зависимости от типа графика:</p>

<table>
<thead>
<tr>
  <th>Параметр</th>
  <th align="left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>amcharts</code></td>
  <td align="left">Базовая библиотека</td>
</tr>
<tr>
  <td><code>amcharts_funnel</code></td>
  <td align="left">Воронка, пирамида Маслоу</td>
</tr>
<tr>
  <td><code>amcharts_gauge</code></td>
  <td align="left">Диаграмма в виде спидометра</td>
</tr>
<tr>
  <td><code>amcharts_pie</code></td>
  <td align="left">Круговая диаграмма</td>
</tr>
<tr>
  <td><code>amcharts_serial</code></td>
  <td align="left">Обычные графики</td>
</tr>
<tr>
  <td><code>amcharts_radar</code></td>
  <td align="left">Радарная диаграмма</td>
</tr>
<tr>
  <td><code>amcharts_xy</code></td>
  <td align="left">График XY</td>
</tr>
</tbody>
</table>

<p><img src="/assets/images/posts/bitrix-js/1.png" alt="" /></p>

<h2>MaskedInput</h2>

<p>В 1С-Битриксе есть библиотека для указания масок ввода – <code>masked_input</code>, которая вполне может стать альтернативой <code>jquery.maskedinput</code>.</p>

<pre><code class="language-php">&lt;?php

CJSCore::Init(['masked_input']);
?&gt;

&lt;input type="text" id="phone" placeholder="Укажите ваш телефон" /&gt;

&lt;script&gt;
    BX.ready(function() {
        var result = new BX.MaskedInput({
            mask: '+7 999 999 99 99', // устанавливаем маску
            input: BX('phone'),
            placeholder: '_' // символ замены +7 ___ ___ __ __
        });

        result.setValue('9000000000'); // устанавливаем значение
    });
&lt;/script&gt;
</code></pre>

<h2>PhoneNumber</h2>

<p>Хотя для масок телефонного номера лучше использовать другую библиотеку — <code>phone_number</code>.</p>

<pre><code class="language-php">&lt;?php

CJSCore::Init(['phone_number']);
?&gt;

&lt;span id="flag"&gt;&lt;/span&gt;
&lt;input type="text" id="number" placeholder="Укажите ваш телефон" /&gt;

&lt;script&gt;
    BX.ready(function() {
        new BX.PhoneNumber.Input({
            node: BX('number'),
            forceLeadingPlus: false, // принудительно установить +
            flagNode: BX('flag'), //
            flagSize: 16, // Размер флага [16, 24, 32]
            defaultCountry: 'ru', // Страна по-умолчанию
            onChange: function(e) {
              // вызывается при изменении значения
            }
        });
    });
&lt;/script&gt;
</code></pre>

<p><img src="/assets/images/posts/bitrix-js/2.png" alt="" /></p>

<h2>PopupWindowManager</h2>

<p>Всплывающие окна в 1С-Битрикс можно организовать с помощью <code>BX.PopupWindowManager</code>. Данная библиотека подходит, как для диалоговых окон, так и полноценных всплывающих страниц:</p>

<pre><code class="language-php">&lt;?php

CJSCore::Init(['popup']);
?&gt;

&lt;script&gt;
    // BX.element - элемент, к которому будет привязано окно, если null – окно появится по центру экрана

    BX.ready(function () {
        var popup = BX.PopupWindowManager.create("popup-message", BX('element'), {
            content: 'Контент, отображаемый в теле окна',
            width: 400, // ширина окна
            height: 100, // высота окна
            zIndex: 100, // z-index
            closeIcon: {
                // объект со стилями для иконки закрытия, при null - иконки не будет
                opacity: 1
            },
            titleBar: 'Заголовок окна',
            closeByEsc: true, // закрытие окна по esc
            darkMode: false, // окно будет светлым или темным
            autoHide: false, // закрытие при клике вне окна
            draggable: true, // можно двигать или нет
            resizable: true, // можно ресайзить
            min_height: 100, // минимальная высота окна
            min_width: 100, // минимальная ширина окна
            lightShadow: true, // использовать светлую тень у окна
            angle: true, // появится уголок
            overlay: {
                // объект со стилями фона
                backgroundColor: 'black',
                opacity: 500
            }, 
            buttons: [
                new BX.PopupWindowButton({
                    text: 'Сохранить', // текст кнопки
                    id: 'save-btn', // идентификатор
                    className: 'ui-btn ui-btn-success', // доп. классы
                    events: {
                      click: function() {
                          // Событие при клике на кнопку
                      }
                    }
                }),
                new BX.PopupWindowButton({
                    text: 'Копировать',
                    id: 'copy-btn',
                    className: 'ui-btn ui-btn-primary',
                    events: {
                      click: function() {

                      }
                    }
                })
            ],
            events: {
               onPopupShow: function() {
                  // Событие при показе окна
               },
               onPopupClose: function() {
                  // Событие при закрытии окна                
               }
            }
        });

        popup.show();
    });
&lt;/script&gt;
</code></pre>

<p><img src="/assets/images/posts/bitrix-js/3.png" alt="" /></p>

<h2>PopupMenu</h2>

<p>Выпадающие меню и списки в стиле Битрикс24 можно сделать с помощью <code>PopupMenu</code>:</p>

<pre><code class="language-php">&lt;?php

CJSCore::Init(['popup']);
?&gt;

&lt;div style="background: red; width: 100px; height: 40px; margin-left: 500px" id="element"&gt;&lt;/div&gt;

&lt;script&gt;
    BX.ready(function () {
        BX.bind(BX('element'), 'click', function () {
            BX.PopupMenu.show('demo-popup-menu', BX('element'), [
                {
                    text: 'Обычный пункт', // Название пункта
                    href: '#', // Ссылка
                    className: 'menu-popup-item menu-popup-no-icon', // Дополнительные классы
                    onclick: function(e, item){
                       BX.PreventDefault(e);
                       // Событие при клике на пункт
                    }
                },
                {
                    text: 'Выбранный пункт',
                    href: '#',
                    className: 'menu-popup-item menu-popup-item-accept'
                }
            ], {
              autoHide : true, // Закрытие меню при клике вне меню
              offsetTop: 0, // смещение от элемента по Y
              zIndex: 10000, // z-index
              offsetLeft: 100,  // смещение от элемента по X
              angle: { offset: 45 }, // Описание уголка, при null – уголка не будет
              events: {
                 onPopupShow: function() {
                    // Событие при показе меню          
                 },
                 onPopupClose : function(){
                    // Событие при закрытии меню
                 },
                 onPopupClose : function(){
                    // Событие при уничтожении объекта меню
                 }
              }
            });
        });
    });
&lt;/script&gt;
</code></pre>

<p><img src="/assets/images/posts/bitrix-js/4.png" alt="" /></p>

<h2>SpotLight</h2>

<p>Если необходимо привлечь внимание пользователя к элементу (например, инструкция по оформлению брони для новых менеджеров, или нужно уведомить о новом функционале) – с этим справится <code>SpotLight</code>.</p>

<pre><code class="language-php">&lt;?php

CJSCore::Init(['spotlight']);
?&gt;

&lt;div style="background: red; width: 100px; height: 40px; margin-left: 500px" id="element"&gt;&lt;/div&gt;

&lt;script&gt;
    BX.ready(function () {
        var obj = new BX.SpotLight({
            renderTo: BX('element'), // Привязать к элементу
            top: 0, // позиционирование относительно элемента
            left: 0, // позиционирование относительно элемента
            content: '1. Сначала нажмите на эту кнопку',
            lightMode: false, // Темный режим или светлый
            observerTimeout: 10000, // Таймаут автопоказа
            events: {
                onPopupShow: function() {
                  // Событие при показе подсказки
                }
            }

        });

        obj.show();
    });
&lt;/script&gt;
</code></pre>

<p><img src="/assets/images/posts/bitrix-js/5.png" alt="" /></p>

<h2>ColorPicker</h2>

<p>Если необходимо выбрать цвет на сайте – для этого есть <code>ColorPicker</code>.</p>

<pre><code class="language-php">&lt;?php

CJSCore::Init(['color_picker']);
?&gt;

&lt;input type="text" id="example" /&gt;

&lt;script&gt;
  BX.ready(function() {
    var element = BX('example');

    BX.bind(element, 'focus', function () {
        new BX.ColorPicker({
            bindElement: element, // Элемент, к которому будет прикреплена область с выбором цвета
            defaultColor: '#FF6600', // Цвет по-умолчанию
            allowCustomColor: true, // Разрешить указывать произвольный цвет
            onColorSelected: function (item) {
                element.value = item // Вызывается при выборе цвета
            },
            popupOptions: {
                angle: true, // треугольник
                autoHide: true, // Закрытие по клику вне области
                closeByEsc: true, // Закрытие по esc
                events: {
                    onPopupClose: function () {
                        // Вызывается при закрытии окна
                    }
                }
            }
        }).open();
    })
  }
&lt;/script&gt;
</code></pre>

<p><img src="/assets/images/posts/bitrix-js/6.png" alt="" /></p>

<h2>Списки</h2>

<p>Чтобы сделать красивые выпадающие списки в стиле Битрикс24, необходимо правильно разметить html-вёрстку:</p>

<pre><code class="language-php">&lt;?php
CJSCore::Init(['ui']);

$items = [
    ['NAME' =&gt; 'Первый вариант', 'VALUE' =&gt; '1'],
    ['NAME' =&gt; 'Второй вариант', 'VALUE' =&gt; '2'],
];
?&gt;

&lt;div style="padding: 100px" id="filter"&gt;
    &lt;div data-name="SELECT_SINGLE" class="main-ui-filter-wield-with-label main-ui-filter-date-group main-ui-control-field-group"&gt;
        &lt;span class="main-ui-control-field-label"&gt;Одиночный выбор&lt;/span&gt;
        &lt;div data-name="SELECT_SINGLE"
             data-items='&lt;?= \Bitrix\Main\Web\Json::encode($items); ?&gt;'
             data-params='&lt;?= \Bitrix\Main\Web\Json::encode(['isMulti' =&gt; false]); ?&gt;'
             id="select" class="main-ui-control main-ui-select"&gt;

            &lt;span class="main-ui-select-name"&gt;Выберите&lt;/span&gt;
            &lt;span class="main-ui-square-search"&gt;
            &lt;input type="text" tabindex="2" class="main-ui-square-search-item"&gt;
        &lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div data-name="SELECT_MULTIPLE" class="main-ui-filter-wield-with-label main-ui-filter-date-group main-ui-control-field-group"&gt;
        &lt;span class="main-ui-control-field-label"&gt;Множественный выбор&lt;/span&gt;
        &lt;div data-name="SELECT_MULTIPLE"
             data-items='&lt;?= \Bitrix\Main\Web\Json::encode($items); ?&gt;'
             data-params='&lt;?= \Bitrix\Main\Web\Json::encode(['isMulti' =&gt; true]); ?&gt;'
             id="select2" class="main-ui-control main-ui-multi-select"&gt;

            &lt;span class="main-ui-square-container"&gt;&lt;/span&gt;
            &lt;span class="main-ui-square-search"&gt;&lt;input type="text" tabindex="2" class="main-ui-square-search-item"&gt;&lt;/span&gt;
            &lt;span class="main-ui-hide main-ui-control-value-delete"&gt;&lt;span class="main-ui-control-value-delete-item"&gt;&lt;/span&gt;&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;span class="ui-btn-primary ui-btn" id="update_filter"&gt;Найти&lt;/span&gt;
&lt;/div&gt;
</code></pre>

<p>Минусы этого подхода – результаты списков придётся получать с помощью <code>JavaScript</code>.</p>

<pre><code class="language-html">&lt;script&gt;
    BX.ready(function() {
        var filter = BX('filter'),
            submit = BX('update_filter');

        BX.bind(submit, 'click', function() {
            var fields = BX.findChildren(filter, {
                attribute: 'data-name',
                className: 'main-ui-control'
            }, true);

            fields.forEach(function(element){
                console.log(element.getAttribute('data-name'));
                console.log(JSON.parse(element.getAttribute('data-value')));
            });
        })
    })
&lt;/script&gt;
</code></pre>

<p><img src="/assets/images/posts/bitrix-js/7.png" alt="" /></p>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/bitrix-grid-filter</link>
    <pubDate>Wed, 03 Jul 2019 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Гриды и фильтры в 1С-Битрикс</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/bitrix-grid-filter/cover.jpg">
            </figure>
        </header>
        <p>Скорее всего, вы сталкивались с задачей вывести в публичной части (да и в административном разделе) проекта какую-либо служебную информацию для пользователей в табличном виде.
Наверняка, вы писали собственные шаблоны для компонентов и потом добавляли костыли для фильтрации и сортировки этих данных.</p>

<p>Начиная с версии <code>17.0.7</code> Главного модуля 1С-Битрикс вышли два компонента: <code>bitrix:main.ui.filter</code> и <code>bitrix:main.ui.grid</code> с классами <code>Bitrix\Main\UI\Filter</code> и <code>Bitrix\Main\Grid</code> (есть даже в редакции «Первый сайт»).</p>

<p><img src="/assets/images/posts/bitrix-grid-filter/1.png" alt="" /></p>

<h2>Гриды</h2>

<p>За вывод грида отвечает компонент <code>bitrix:main.ui.grid</code>. Параметры:</p>

<table>
<thead>
<tr>
  <th>Параметр</th>
  <th align="left">Тип</th>
  <th align="left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
  <td>GRID_ID</td>
  <td align="left">string</td>
  <td align="left">Идентификатор грида (такой же, как у фильтра)</td>
</tr>
<tr>
  <td>COLUMNS</td>
  <td align="left">array</td>
  <td align="left">Массив с заголовками грида</td>
</tr>
<tr>
  <td>ROWS</td>
  <td align="left">array</td>
  <td align="left">Массив с значениями грида, действиями в контекстном меню</td>
</tr>
<tr>
  <td>SHOW_ROW_CHECKBOXES</td>
  <td align="left">bool</td>
  <td align="left">Показывать чекбоксы у строк для множественных действий</td>
</tr>
<tr>
  <td>NAV_OBJECT</td>
  <td align="left">object</td>
  <td align="left">Объект для постраничной навигации</td>
</tr>
<tr>
  <td>AJAX_MODE</td>
  <td align="left">string</td>
  <td align="left">Использовать ли ajax режим</td>
</tr>
<tr>
  <td>AJAX_ID</td>
  <td align="left">string</td>
  <td align="left">Ajax ID Берётся из компонента фильтра</td>
</tr>
<tr>
  <td>PAGE_SIZES</td>
  <td align="left">array</td>
  <td align="left">Массив для выпадающего списка с выбором кол-ва элементов на странице</td>
</tr>
<tr>
  <td>AJAX_OPTION_JUMP</td>
  <td align="left">string</td>
  <td align="left"></td>
</tr>
<tr>
  <td>AJAX_OPTION_JUMP</td>
  <td align="left">string</td>
  <td align="left"></td>
</tr>
<tr>
  <td>SHOW_CHECK_ALL_CHECKBOXES</td>
  <td align="left">bool</td>
  <td align="left">Показывать "Выбрать все"</td>
</tr>
<tr>
  <td>SHOW_ROW_ACTIONS_MENU</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
<tr>
  <td>SHOW_GRID_SETTINGS_MENU</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
<tr>
  <td>SHOW_NAVIGATION_PANEL</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
<tr>
  <td>SHOW_PAGINATION</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
<tr>
  <td>SHOW_SELECTED_COUNTER</td>
  <td align="left">bool</td>
  <td align="left">Показывать "Выбрано элементов"</td>
</tr>
<tr>
  <td>SHOW_TOTAL_COUNTER</td>
  <td align="left">bool</td>
  <td align="left">Показывать "Всего элементов"</td>
</tr>
<tr>
  <td>SHOW_PAGESIZE</td>
  <td align="left">bool</td>
  <td align="left">Выводить выпадающий список с выбором кол-ва элементов на странице</td>
</tr>
<tr>
  <td>SHOW_ACTION_PANEL</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
<tr>
  <td>ALLOW_COLUMNS_SORT</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
<tr>
  <td>ALLOW_COLUMNS_RESIZE</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
<tr>
  <td>ALLOW_HORIZONTAL_SCROLL</td>
  <td align="left">bool</td>
  <td align="left">Будет доступен горизонтальный скролл</td>
</tr>
<tr>
  <td>ALLOW_SORT</td>
  <td align="left">bool</td>
  <td align="left">Разрешить сортировку</td>
</tr>
<tr>
  <td>ALLOW_PIN_HEADER</td>
  <td align="left">bool</td>
  <td align="left">Разрешать закреплять шапку грида</td>
</tr>
<tr>
  <td>AJAX_OPTION_HISTORY</td>
  <td align="left">bool</td>
  <td align="left"></td>
</tr>
</tbody>
</table>

<p>Пример вызова компонента:</p>

<pre><code class="language-php">&lt;?php

$grid_options = new Bitrix\Main\Grid\Options('report_list');
$sort = $grid_options-&gt;GetSorting(['sort' =&gt; ['ID' =&gt; 'DESC'], 'vars' =&gt; ['by' =&gt; 'by', 'order' =&gt; 'order']]);
$nav_params = $grid_options-&gt;GetNavParams();

$nav = new Bitrix\Main\UI\PageNavigation('report_list');
$nav-&gt;allowAllRecords(true)
    -&gt;setPageSize($nav_params['nPageSize'])
    -&gt;initFromUri();

// Кнопка удалить
$onchange = new Onchange();
$onchange-&gt;addAction(
    [
        'ACTION' =&gt; Actions::CALLBACK,
        'CONFIRM' =&gt; true,
        'CONFIRM_APPLY_BUTTON'  =&gt; 'Подтвердить',
        'DATA' =&gt; [
            ['JS' =&gt; 'Grid.removeSelected()']
        ]
    ]
);

$APPLICATION-&gt;IncludeComponent('bitrix:main.ui.grid', '', [ 
    'GRID_ID' =&gt; 'report_list', 
    'COLUMNS' =&gt; [ 
        ['id' =&gt; 'ID', 'name' =&gt; 'ID', 'sort' =&gt; 'ID', 'default' =&gt; true], 
        ['id' =&gt; 'DATE', 'name' =&gt; 'Дата', 'sort' =&gt; 'DATE', 'default' =&gt; true], 
        ['id' =&gt; 'AMOUNT', 'name' =&gt; 'Сумма', 'sort' =&gt; 'AMOUNT', 'default' =&gt; true], 
        ['id' =&gt; 'PAYER_INN', 'name' =&gt; 'ИНН Плательщика', 'sort' =&gt; 'PAYER_INN', 'default' =&gt; true], 
        ['id' =&gt; 'PAYER_NAME', 'name' =&gt; 'Плательщик', 'sort' =&gt; 'PAYER_NAME', 'default' =&gt; true], 
        ['id' =&gt; 'IS_SPEND', 'name' =&gt; 'Тип операции', 'sort' =&gt; 'IS_SPEND', 'default' =&gt; true], 
    ], 
    'ROWS' =&gt; $list, //Самое интересное, опишем ниже
    'SHOW_ROW_CHECKBOXES' =&gt; true, 
    'NAV_OBJECT' =&gt; $nav, 
    'AJAX_MODE' =&gt; 'Y', 
    'AJAX_ID' =&gt; \CAjax::getComponentID('bitrix:main.ui.grid', '.default', ''), 
    'PAGE_SIZES' =&gt; [ 
        ['NAME' =&gt; "5", 'VALUE' =&gt; '5'], 
        ['NAME' =&gt; '10', 'VALUE' =&gt; '10'], 
        ['NAME' =&gt; '20', 'VALUE' =&gt; '20'], 
        ['NAME' =&gt; '50', 'VALUE' =&gt; '50'], 
        ['NAME' =&gt; '100', 'VALUE' =&gt; '100'] 
    ], 
    'AJAX_OPTION_JUMP'          =&gt; 'N', 
    'SHOW_CHECK_ALL_CHECKBOXES' =&gt; true, 
    'SHOW_ROW_ACTIONS_MENU'     =&gt; true, 
    'SHOW_GRID_SETTINGS_MENU'   =&gt; true, 
    'SHOW_NAVIGATION_PANEL'     =&gt; true, 
    'SHOW_PAGINATION'           =&gt; true, 
    'SHOW_SELECTED_COUNTER'     =&gt; true, 
    'SHOW_TOTAL_COUNTER'        =&gt; true, 
    'SHOW_PAGESIZE'             =&gt; true, 
    'SHOW_ACTION_PANEL'         =&gt; true, 
    'ACTION_PANEL'              =&gt; [ 
        'GROUPS' =&gt; [ 
            'TYPE' =&gt; [ 
                'ITEMS' =&gt; [ 
                    [ 
                        'ID'    =&gt; 'set-type', 
                        'TYPE'  =&gt; 'DROPDOWN', 
                        'ITEMS' =&gt; [ 
                            ['VALUE' =&gt; '', 'NAME' =&gt; '- Выбрать -'], 
                            ['VALUE' =&gt; 'plus', 'NAME' =&gt; 'Поступление'], 
                            ['VALUE' =&gt; 'minus', 'NAME' =&gt; 'Списание'] 
                        ] 
                    ], 
                    [ 
                        'ID'       =&gt; 'edit', 
                        'TYPE'     =&gt; 'BUTTON', 
                        'TEXT'        =&gt; 'Редактировать', 
                        'CLASS'        =&gt; 'icon edit', 
                        'ONCHANGE' =&gt; '' 
                    ], 
                    [
                        'ID'       =&gt; 'delete',
                        'TYPE'     =&gt; 'BUTTON',
                        'TEXT'     =&gt; 'Удалить',
                        'CLASS'    =&gt; 'icon remove',
                        'ONCHANGE' =&gt; $onchange-&gt;toArray()
                    ],
                ], 
            ] 
        ], 
    ], 
    'ALLOW_COLUMNS_SORT'        =&gt; true, 
    'ALLOW_COLUMNS_RESIZE'      =&gt; true, 
    'ALLOW_HORIZONTAL_SCROLL'   =&gt; true, 
    'ALLOW_SORT'                =&gt; true, 
    'ALLOW_PIN_HEADER'          =&gt; true, 
    'AJAX_OPTION_HISTORY'       =&gt; 'N' 
]);
</code></pre>

<p>Передаём данные в грид:</p>

<pre><code class="language-php">&lt;?php

$list = [
    [
        'data'    =&gt; [ //Данные ячеек
        "ID" =&gt; 1,
            "NAME" =&gt; "Название 1",
            "AMOUNT" =&gt; 1000,
            "PAYER_NAME" =&gt; "Плательщик 1"
        ],
        'actions' =&gt; [ //Действия над ними
            [
                'text'    =&gt; 'Редактировать',
                'onclick' =&gt; 'document.location.href="/accountant/reports/1/edit/"'
            ],
            [
                'text'    =&gt; 'Удалить',
                'onclick' =&gt; 'document.location.href="/accountant/reports/1/delete/"'
            ]

        ],
    ], [
        'data'    =&gt; [ //Данные ячеек
            "ID" =&gt; 2,
            "NAME" =&gt; "Название 2",
            "AMOUNT" =&gt; 3000,
            "PAYER_NAME" =&gt; "Плательщик 2"
        ],
        'actions' =&gt; [ //Действия над ними
            [
                'text'    =&gt; 'Редактировать',
                'onclick' =&gt; 'document.location.href="/accountant/reports/2/edit/"'
            ],
            [
                'text'    =&gt; 'Удалить',
                'onclick' =&gt; 'document.location.href="/accountant/reports/2/delete/"'
            ]
        ],
    ]
];
</code></pre>

<p>Результат вывода:</p>

<p><img src="/assets/images/posts/bitrix-grid-filter/2.png" alt="" /></p>

<p>Панель действий <code>ACTION_PANEL</code>:</p>

<p><img src="/assets/images/posts/bitrix-grid-filter/3.png" alt="" /></p>

<h2>Фильтр</h2>

<p>За фильтрацию отвечает компонент <code>bitrix:main.ui.filter</code>. Его параметры:</p>

<table>
<thead>
<tr>
  <th>Параметр</th>
  <th align="left">Тип</th>
  <th align="left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
  <td>FILTER_ID</td>
  <td align="left">string</td>
  <td align="left">Идентификатор фильтра (должен быть уникальным)</td>
</tr>
<tr>
  <td>GRID_ID</td>
  <td align="left">string</td>
  <td align="left">Идентификатор грида к которому применяем фильтр</td>
</tr>
<tr>
  <td>FILTER</td>
  <td align="left">array</td>
  <td align="left">Массив с полями для фильтрации</td>
</tr>
<tr>
  <td>ENABLE_LABEL</td>
  <td align="left">bool</td>
  <td align="left">Показывать название полей или нет</td>
</tr>
<tr>
  <td>ENABLE_LIVE_SEARCH</td>
  <td align="left">bool</td>
  <td align="left">Будет ли доступна live-фильтрация</td>
</tr>
</tbody>
</table>

<p>Пример вызова:</p>

<pre><code class="language-php">&lt;?php

$APPLICATION-&gt;IncludeComponent('bitrix:main.ui.filter', '', [ 
    'FILTER_ID' =&gt; 'report_list', 
    'GRID_ID' =&gt; 'report_list', 
    'FILTER' =&gt; [ 
        ['id' =&gt; 'DATE', 'name' =&gt; 'Дата', 'type' =&gt; 'date'], 
        ['id' =&gt; 'IS_SPEND', 'name' =&gt; 'Тип операции', 'type' =&gt; 'list', 'items' =&gt; ['' =&gt; 'Любой', 'P' =&gt; 'Поступление', 'M' =&gt; 'Списание'], 'params' =&gt; ['multiple' =&gt; 'Y']],
        ['id' =&gt; 'AMOUNT', 'name' =&gt; 'Сумма', 'type' =&gt; 'number'], 
        ['id' =&gt; 'PAYER_INN', 'name' =&gt; 'ИНН Плательщика', 'type' =&gt; 'number'], 
        ['id' =&gt; 'PAYER_NAME', 'name' =&gt; 'Плательщик'], 
    ], 
    'ENABLE_LIVE_SEARCH' =&gt; true, 
    'ENABLE_LABEL' =&gt; true 
]);
</code></pre>

<p>Результат:</p>

<p><img src="/assets/images/posts/bitrix-grid-filter/4.png" alt="" /></p>

<p>Также фильтры можно сохранять для быстрого использования:</p>

<p><img src="/assets/images/posts/bitrix-grid-filter/5.png" alt="" /></p>

<h2>Связка фильтра и грида</h2>

<p>Чтобы пробросить данные из фильтра в грид, необходимо собрать фильтр:</p>

<pre><code class="language-php">&lt;?php

$filter = [];
$filterOption = new Bitrix\Main\UI\Filter\Options('report_list');
$filterData = $filterOption-&gt;getFilter([]);
foreach ($filterData as $k =&gt; $v) {
    $filter[$k] = $v;            
}
</code></pre>

<h2>Фильтрация любых данных</h2>

<p>Связка Фильтр-Грид работает в 1С-Битрикс по умолчанию, но иногда хочется такую фильтрацию добавить к своим данным, например, к выводу графика:</p>

<p><img src="/assets/images/posts/bitrix-grid-filter/6.png" alt="" /></p>

<p>Для того, чтобы это заработало, необходимо «подписаться» на событие применения фильтра:</p>

<pre><code class="language-html">&lt;script type="text/javascript"&gt;
BX.addCustomEvent('BX.Main.Filter:apply', BX.delegate(function (command, params) { 
    var workarea = $('#' + command); // в command будет храниться GRID_ID из фильтра 

    $.post(window.location.href, function(data){ 
        workarea.html($(data).find('#' + command).html()); 
    }) 
}));
&lt;/script&gt;
</code></pre>

<h2>Хаки</h2>

<p>Почему-то 1С-Битрикс в своих компонентах автоматически не подцепляет css-файл со стилями кнопок (на момент написания статьи),
поэтому перед вызовом компонентов, рекомендуется добавить css-файл вручную:</p>

<pre><code class="language-php">&lt;?php

Bitrix\Main\Page\Asset::getInstance()-&gt;addCss('/bitrix/css/main/grid/webform-button.css');
</code></pre>

<p>Чтобы обновить грид без перезагрузки страницы, воспользуйтесь методом:</p>

<pre><code class="language-html">&lt;script type="text/javascript"&gt;
var reloadParams = { apply_filter: 'Y', clear_nav: 'Y' };
var gridObject = BX.Main.gridManager.getById('report_list'); // Идентификатор грида

if (gridObject.hasOwnProperty('instance')){
  gridObject.instance.reloadTable('POST', reloadParams);
}
&lt;/script&gt;
</code></pre>
        ]]>
    </turbo:content>
</item>            <item turbo="true">
    <turbo:extendedHtml>true</turbo:extendedHtml>
    <extendedHtml></extendedHtml>
    <link>https://s-panteleev.ru/post/bitrix-sites24</link>
    <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
    <author>Сергей Пантелеев</author>
    <turbo:content>
        <![CDATA[
        <header>
            <h1>Сайты 24</h1>
            <figure>
                <img src="https://s-panteleev.ru/assets/images/posts/bitrix-sites24/cover.jpg">
            </figure>
        </header>
        <p>В 1С-Битрикс Управление Сайтом 18.0 стали доступны Сайты 24, добавленные изначально в облачный продукт — Битрикс24.</p>

<p>Сайты 24 позволяют без навыков программирования собирать страницу, как в конструкторе, заменяя текст, картинки и другую
информацию без опасения сломать сайт.</p>

<p>Так выглядит рабочая область созданного сайта.</p>

<p><img src="/assets/images/posts/bitrix-sites24/1.png" alt="" /></p>

<p>В данном примере мы будем использовать шаблон сайта, привычный любому разработчику 1С-Битрикс: Шапка + Подвал +
Рабочая область.</p>

<p><img src="/assets/images/posts/bitrix-sites24/2.png" alt="" /></p>

<p>Каждая область сайта — страница. Страницы в свою очередь состоят из Блоков.</p>

<p>Блоки можно использовать, как готовые, так и разработать самим.</p>

<p>Стандартных блоков довольно много, но бывают ситуации, когда их недостаточно и необходимо разрабатывать
пользовательские.</p>

<p><img src="/assets/images/posts/bitrix-sites24/3.png" alt="" /></p>

<p>Для этого в папке <code>/bitrix/blocks/&lt;company_name&gt;/</code> создайте папку блока <code>header</code>.</p>

<p>Структура Блока:</p>

<table>
<thead>
<tr>
  <th>Файл</th>
  <th align="left">Описание</th>
</tr>
</thead>
<tbody>
<tr>
  <td><code>preview.jpg</code></td>
  <td align="left">Картинка, которая будет отображаться в списке блоков</td>
</tr>
<tr>
  <td><code>block.php</code></td>
  <td align="left">Файл с вёрсткой блока</td>
</tr>
<tr>
  <td><code>.description.php</code></td>
  <td align="left">Файл с описанием блока</td>
</tr>
<tr>
  <td><code>style.css</code></td>
  <td align="left">Файл со стилями блока</td>
</tr>
<tr>
  <td><code>script.php</code></td>
  <td align="left">Файл с подключением JS-библиотек</td>
</tr>
<tr>
  <td><code>/lang/ru/</code></td>
  <td align="left">Директория с языковыми файлами</td>
</tr>
</tbody>
</table>

<p><img src="/assets/images/posts/bitrix-sites24/4.png" alt="" /></p>

<p>В <code>block.php</code> поместите обычный html-код:</p>

<pre><code class="language-html"><br />&lt;div class="header wrapper"&gt;
    &lt;div class="header__logo"&gt;
        &lt;a href="#" class="logo__link"&gt;
            &lt;span class="logo__name"&gt;Заголовок&lt;/span&gt;
            &lt;span class="logo__slogan"&gt;Подзаголовок&lt;/span&gt;
        &lt;/a&gt;
    &lt;/div&gt;
    &lt;div class="header__symbols"&gt;
        Логотипы
    &lt;/div&gt;
    &lt;div class="clear"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Это наш будущий блок. Как видите, программирования тут нет 😃</p>

<p>В файле <code>.description.php</code> размечаются данные, какие можно редактировать, а какие — нет.</p>

<pre><code class="language-php">&lt;?php

if (!defined('B_PROLOG_INCLUDED') || B_PROLOG_INCLUDED !== true) {
    die();
}

use Bitrix\Main\Localization\Loc;

return [
    'block' =&gt; [
        'name' =&gt; Loc::getMessage('LANDING_TEST_SITE_HEADER'), // Название блока в lang-файле
        'section' =&gt; 'menu', // Раздел, в котором он будет отображаться
    ],
    'assets' =&gt; [
        'css' =&gt; [
            '/local/styles/header_block.css', // внешний css файл
        ],
    ],
    'nodes' =&gt; [
        '.logo__link' =&gt; [ // Блок с этим классом можно будет изменять
            'name' =&gt; 'Ссылка',
            'type' =&gt; 'link', // Тип блока
        ],
        '.logo__name' =&gt; [
            'name' =&gt; 'Заголовок',
            'type' =&gt; 'text',
        ],
        '.logo__slogan' =&gt; [
            'name' =&gt; 'Подзаголовок',
            'type' =&gt; 'text',
        ],
    ],
    'attrs' =&gt; [
        '.header__symbols' =&gt; [
            'name' =&gt; 'Скрывать логотипы?',
            'type' =&gt; 'checkbox',
            'attribute' =&gt; 'data-is-hidden', // Добавит к элементу data-is-hidden='["Y"]', при отмеченной галочке (такие элементы можно обрабатывать с помощью css и js)
            'items' =&gt; [
                ['name' =&gt; 'Скрывать логотипы?', 'value' =&gt; 'Y', 'checked' =&gt; true],
            ],
        ],
    ],
];
</code></pre>

<p>В итоге получается такая форма:</p>

<p><img src="/assets/images/posts/bitrix-sites24/5.png" alt="" /></p>

<p>Подробнее про параметры и структуру блока
смотрите <a href="https://dev.1c-bitrix.ru/rest_help/landing/block/manifest.php">на сайте 1С-Битрикс</a>.</p>

<p>Добавьте созданный блок на страницу:</p>

<p><img src="/assets/images/posts/bitrix-sites24/6.png" alt="" /></p>

<p>Теперь добавьте блок с меню. В файл <code>block.php</code> поместите вёрстку:</p>

<pre><code class="language-html"><br />&lt;div class="nav"&gt;
    &lt;div class="wrapper"&gt;
        &lt;ul class="nav__list"&gt;
            &lt;li class="nav__item"&gt;
                &lt;a href="#" class="nav__link"&gt;Ссылка&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class="nav__item"&gt;
                &lt;a href="#" class="nav__link"&gt;Ссылка&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>Разметьте файл <code>.description.php</code>:</p>

<pre><code class="language-php">&lt;?php

if (!defined('B_PROLOG_INCLUDED') || B_PROLOG_INCLUDED !== true) {
    die();
}

return [
    'block' =&gt; [
        'name' =&gt; 'Меню',
        'section' =&gt; 'menu',
    ],
    'assets' =&gt; [
        'css' =&gt; [
            '/local/styles/menu_block.css', // внешний css файл
        ],
    ],
    'cards' =&gt; [
        '.nav__item' =&gt; [ // Повторяющийся блок — карточка
            'name' =&gt; 'Пункт меню',
        ],
    ],
    'nodes' =&gt; [
        '.nav__link' =&gt; [ // Как и в шапке — блок, доступный для редактирования
            'name' =&gt; 'Ссылка',
            'type' =&gt; 'link',
        ],
    ],
    'style' =&gt; [
        'block' =&gt; [
            'type' =&gt; ['display'],
        ],
        'nodes' =&gt; [
            '.nav__link' =&gt; [
                'name' =&gt; 'Ссылка',
                'type' =&gt; 'typo', // К ссылке можно применять типографические стили (размер шрифта, межстрочный интервал и т.д.)
            ],
        ],
    ],
];
</code></pre>

<p>Добавьте блок на сайт и отредактируйте данные:</p>

<p><img src="/assets/images/posts/bitrix-sites24/7.png" alt="" /></p>

<p>Стили для ссылок задаются при просмотре блока на вкладке «Дизайн»:</p>

<p><img src="/assets/images/posts/bitrix-sites24/8.png" alt="" /></p>

<p>Таким образом, без навыков программирования, можно внедрить готовую вёрстку в Сайты 24 и создать полноценный сайт.</p>
        ]]>
    </turbo:content>
</item>        </channel>
</rss>